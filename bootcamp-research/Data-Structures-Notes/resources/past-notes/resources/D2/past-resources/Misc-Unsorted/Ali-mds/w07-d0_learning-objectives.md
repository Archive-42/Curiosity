# WEEK-07 <br>*Learning Objectives* {ignore=true}
________________________________________________________________________________
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=2 orderedList=false} -->
________________________________________________________________________________
________________________________________________________________________________
# GitHub Profile and Projects Objectives

GitHub is a powerful platform that hiring managers and other developers can use
to see how you create software.

* You will be able to participate in the social aspects of GitHub by starring
  repositories, following other developers, and reviewing your followers
* You will be able to use Markdown to write code snippets in your README files
* You will craft your GitHub profile and contribute throughout the course by
  keeping your "gardens green"
* You will be able to identify the basics of a good Wiki entries for proposals
  and minimum viable products
* You will be able to identify the basics of a good project README that includes
  technologies at the top, images, descriptions and code snippetsing managers and other developers can use
to see how you create software.

* You will be able to participate in the social aspects of GitHub by starring
  repositories, following other developers, and reviewing your followers
* You will be able to use Markdown to write code snippets in your README files
* You will craft your GitHub profile and contribute throughout the course by
  keeping your "gardens green"
* You will be able to identify the basics of a good Wiki entries for proposals
  and minimum viable products
* You will be able to identify the basics of a good project README that includes
  technologies at the top, images, descriptions and code snippets

________________________________________________________________________________
# Big O Learning Objectives

**The objective of this lesson** is get you comfortable with identifying the
time and space complexity of code you see. Being able to diagnose time
complexity for algorithms is an essential for interviewing software engineers.

At the end of this, you will be able to

1. Order the common complexity classes according to their growth rate
2. Identify the complexity classes of common sort methods
3. Identify complexity classes of codeable with identifying the
time and space complexity of code you see. Being able to diagnose time
complexity for algorithms is an essential for interviewing software engineers.

At the end of this, you will be able to

1. Order the common complexity classes according to their growth rate
2. Identify the complexity classes of common sort methods
3. Identify complexity classes of code

________________________________________________________________________________
# Memoization And Tabulation Learning Objectives

**The objective of this lesson** is to give you a couple of ways to optimize a
computation (algorithm) from a higher complexity class to a lower complexity
class. Being able to optimize algorithms is an essential for interviewing
software engineers.

At the end of this, you will be able to

1. Apply memoization to recursive problems to make them less than polynomial
   time.
2. Apply tabulation to iterative problems to make them less than polynomial
   time.** is to give you a couple of ways to optimize a
computation (algorithm) from a higher complexity class to a lower complexity
class. Being able to optimize algorithms is an essential for interviewing
software engineers.

At the end of this, you will be able to

1. Apply memoization to recursive problems to make them less than polynomial
   time.
2. Apply tabulation to iterative problems to make them less than polynomial
   time.

________________________________________________________________________________
# Sorting Algorithms

**The objective of this lesson** is for you to get experience implementing
common sorting algorithms that will come up during a lot of interviews. It is
also important for you to understand how different sorting algorithms behave
when given output.

At the end of this, you will be able to

1. Explain the complexity of and write a function that performs `bubble sort` on
   an array of numbers.
2. Explain the complexity of and write a function that performs `selection sort`
   on an array of numbers.
3. Explain the complexity of and write a function that performs `insertion sort`
   on an array of numbers.
4. Explain the complexity of and write a function that performs `merge sort` on
   an array of numbers.
5. Explain the complexity of and write a function that performs `quick sort` on
   an array of numbers.
6. Explain the complexity of and write a function that performs a binary search
   on a sorted array of numbers.nce implementing
common sorting algorithms that will come up during a lot of interviews. It is
also important for you to understand how different sorting algorithms behave
when given output.

At the end of this, you will be able to

1. Explain the complexity of and write a function that performs `bubble sort` on
   an array of numbers.
2. Explain the complexity of and write a function that performs `selection sort`
   on an array of numbers.
3. Explain the complexity of and write a function that performs `insertion sort`
   on an array of numbers.
4. Explain the complexity of and write a function that performs `merge sort` on
   an array of numbers.
5. Explain the complexity of and write a function that performs `quick sort` on
   an array of numbers.
6. Explain the complexity of and write a function that performs a binary search
   on a sorted array of numbers.

________________________________________________________________________________
# Lists, Stacks, and Queues

**The objective of this lesson** is for you to become comfortable with
implementing common data structures. This is important because questions about
data structures are incredibly likely to be interview questions for software
engineers from junior to senior levels. Moreover, understanding how different
data structures work will influence the libraries and frameworks that you choose
when writing software.

When you are done, you will be able to:

1. Explain and implement a List.
2. Explain and implement a Stack.
3. Explain and implement a Queue.me comfortable with
implementing common data structures. This is important because questions about
data structures are incredibly likely to be interview questions for software
engineers from junior to senior levels. Moreover, understanding how different
data structures work will influence the libraries and frameworks that you choose
when writing software.

When you are done, you will be able to:

1. Explain and implement a List.
2. Explain and implement a Stack.
3. Explain and implement a Queue.

________________________________________________________________________________
# Graphs and Heaps

**The objective of this lesson** is for you to become comfortable with
implementing common data structures. This is important because questions about
data structures are incredibly likely to be interview questions for software
engineers from junior to senior levels. Moreover, understanding how different
data structures work will influence the libraries and frameworks that you choose
when writing software.

When you are done, you will be able to:

1. Explain and implement a Heap.
2. Explain and implement a Graph.table with
implementing common data structures. This is important because questions about
data structures are incredibly likely to be interview questions for software
engineers from junior to senior levels. Moreover, understanding how different
data structures work will influence the libraries and frameworks that you choose
when writing software.

When you are done, you will be able to:

1. Explain and implement a Heap.
2. Explain and implement a Graph.
