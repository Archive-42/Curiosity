{
  "data": {
    "markdownRemark": {
      "html": "<h1>State Machine:</h1>\n<p>Collection of states\nCollection of transitions between states</p>\n<h2>Transitions:</h2>\n<p>Type of event that triggers the state to go from one state to another</p>\n<p>All computable/calculable problems can be represented as a state machine.</p>\n<h1>Human example:</h1>\n<h2>Hungry toddler:</h2>\n<h3>Current state:</h3>\n<p>Hungry</p>\n<p>If you input donut, you may end up with transition to Hyperactive Toddler.</p>\n<p>If you input fruit, you may end up with a Content Toddler.</p>\n<h1>Computing Example:</h1>\n<h2>Receiving Boolean inputs:</h2>\n<p>Mouse click, button click, etc.</p>\n<h2>Numerical/text input:</h2>\n<p>Via keyboard or other input device</p>\n<h1>Simple states are on/off but there are other states a machine can enter.</h1>\n<p>State change usually conveyed to us through output device (screen changing color, etc.).</p>\n<h1>Notation:</h1>\n<h2>Example: Light bulb</h2>\n<p>State1 (off) State2(on)</p>\n<h3>Input type: light switch:</h3>\n<p>a) no action (don't necessarily have to put no action on state machine, but used to illustrate possible transition)\nb) switch toggled</p>\n<h2>If current state of light bulb is off:</h2>\n<p>a - does not change state\nb - changes state</p>\n<p>In a state diagram, you use arrows and label with what type of action performed and the arrow shows what state you started in and what state you end up in after the action is taken.</p>\n<p>Often you'll see transitions labeled with a key.</p>\n<h2>Oregon Trail</h2>\n<p>State 1(sick) State2(healthy) State3(dead)</p>\n<h3>Transitions:</h3>\n<p>a) continue on the trail\nb) increase the pace\nc) decrease the pace\nd) increase food ration\ne) decrease food ration\nf) stop to rest</p>\n<p>Without looking at source code, just from experience:</p>\n<p>If starting from State 1(sick):\nInput of a || b || e transitions to State 3(dead)</p>\n<p>If starting from State 1(sick):\nInput of f || d || c, stay in State 1(sick)</p>\n<p>If starting from State 1(sick):\nInput of c &#x26;&#x26; d &#x26;&#x26; f, transition to State 2(healthy)</p>\n<p>State machines are great to illustrate the logic of our program, how it will behave given states and inputs.</p>\n<p>State machines can have no ambiguity\nThere must be clearly defined output for all possible state/input combinations.</p>",
      "frontmatter": {
        "date": "2018-08-01",
        "title": "State Machines",
        "chapter": null,
        "subtitle": null,
        "tags": ["state machines", "theory of computation"],
        "path": "/State-Machines"
      }
    }
  },
  "pageContext": {
    "isCreatedByStatefulCreatePages": false,
    "pathSlug": "/State-Machines",
    "prev": {
      "frontmatter": {
        "path": "/Regex",
        "title": "Regex",
        "tags": ["regex", "theory of computation"],
        "subtitle": null,
        "chapter": null
      }
    },
    "next": {
      "frontmatter": {
        "path": "/CS8-Operating-Systems-I",
        "title": "CS8: Operating Systems I",
        "tags": ["CS8", "operating systems"],
        "subtitle": null,
        "chapter": null
      }
    }
  }
}
