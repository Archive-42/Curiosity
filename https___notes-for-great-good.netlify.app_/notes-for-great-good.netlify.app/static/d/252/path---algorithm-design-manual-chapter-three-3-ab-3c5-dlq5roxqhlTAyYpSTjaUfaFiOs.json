{
  "data": {
    "markdownRemark": {
      "html": "<h3>Contiguous vs. Linked Data Structures:</h3>\n<p><strong>Contiguous</strong>: single slab of memory - arrays, matrices, heaps, hash tables\n<strong>Linked</strong>: distinct chunks of memory bound together by pointer - lists, trees, graphs, graph adjacency lists</p>\n<h3>Arrays</h3>\n<p>Structures of fixed-sized data records where each element can be efficiently accessed via index</p>\n<p><strong>Advantages</strong></p>\n<ul>\n<li>Constant-time access via index</li>\n<li>Space efficiency - only require space enough for data</li>\n<li>Memory locality - physical proximity of successive data allows for exploitations of memory caching</li>\n</ul>\n<h3>Pointers and Linked Structures</h3>\n<p><strong>Pointers</strong> represent the address of a location in memory</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">list</span> <span class=\"token punctuation\">{</span>\n    item_type item<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* data item */</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">list</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* point to successor */</span>\n<span class=\"token punctuation\">}</span> list<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>Each node in list contains one or more data fields (item) that store the data necessary</li>\n<li>Each node contains a pointer to at least one other node (next), which means most of the space used in the data structure has to be devoted to pointers, not data</li>\n<li>Need pointer to head of structure to know where to access it</li>\n</ul>\n<p><strong>Searching a list</strong> - can be done iteratively or recursively.</p>\n<p>Recursive implementation of a search:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">list <span class=\"token operator\">*</span><span class=\"token function\">search_list</span><span class=\"token punctuation\">(</span>list <span class=\"token operator\">*</span>l<span class=\"token punctuation\">,</span> item_type x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">-></span> item <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span> <span class=\"token function\">search_list</span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>next<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>Insertion</strong> - insertion at the beginning avoides traversal, but have to update pointer</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">insert_list</span><span class=\"token punctuation\">(</span>list <span class=\"token operator\">*</span><span class=\"token operator\">*</span>l<span class=\"token punctuation\">,</span> item_type x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    list <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n    p <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    p<span class=\"token operator\">-></span>item <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    p<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>l<span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">*</span>l <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Copies p to the place pointed to by l\n}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>Deletion from a list</strong> - more complicated because you need to find the pointedr for the predecessor of the item you want to delete. Recursion!</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">list <span class=\"token operator\">*</span><span class=\"token function\">predecessor_list</span><span class=\"token punctuation\">(</span>list <span class=\"token operator\">*</span>l<span class=\"token punctuation\">,</span> item_type x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>l <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>next <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">/* predecessor sought on null list */</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>next<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>item <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span> <span class=\"token function\">predecessor_list</span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>next<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Predecessor is necessary because we need to change 'next' reference.</p>\n<p>Deletion is simple after ruling out that the delete item does not exist. Have to make sure to reset pointer to head if deleting first element.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">delete_list</span><span class=\"token punctuation\">(</span>list <span class=\"token operator\">*</span><span class=\"token operator\">*</span>l<span class=\"token punctuation\">,</span> item_type x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    list <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* item pointer */</span>\n    list <span class=\"token operator\">*</span>pred<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* predecessor pointer */</span>\n    list <span class=\"token operator\">*</span><span class=\"token function\">search_list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token function\">predecessor_list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    p <span class=\"token operator\">=</span> <span class=\"token function\">search_list</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>l<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        pred <span class=\"token operator\">=</span> <span class=\"token function\">predecessor_list</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>l<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pred <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">/* splice out of list */</span>\n        <span class=\"token operator\">*</span>l <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        pred<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token comment\">/* Free memory used by node */</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Comparisons:</h3>\n<p><strong>Advantages of linked lists over static arrays</strong>:</p>\n<ul>\n<li>Overflow can never occur unless memory actually full</li>\n<li>Insertions/deletions are simpler</li>\n<li>With large records, moving pointers is easier and faster than moving items themselves</li>\n</ul>\n<p><strong>Advantages of arrays</strong>:</p>\n<ul>\n<li>Linked lists require extra space for storing pointers</li>\n<li>Linked lists do not allow for random access</li>\n<li>Arrays allow for better memory locality and cache performance than random pointer jumping</li>\n</ul>\n<p><strong>Take Home</strong>: Dynamic memory allocation provides us with flexibility on how and where we use our limited storage resources</p>\n<h3>Stacks and Queues:</h3>\n<p><strong>Container</strong>: Data structure that permits storage and retrieval of data items <em>independent of content</em>, unlike dictionaries which are abstract data types that retrieve based on key, values, or content.</p>\n<p>Containers are distinguished by retrieval order support. In two of the most important types of container, retrieval order is based on insertion order.</p>\n<p><strong>Stacks</strong>: Last in, first out (LIFO) - simple to implement and efficient, so good container to use if retrieval order doesn't matter, such as processing batch jobs. <em>put</em> and <em>get</em> operations usually called 'push' and 'pop'.\n<code class=\"language-text\">push(x, s) -&gt; insert item x at top of stack s</code>\n<code class=\"language-text\">pop(s) -&gt; return (and remove) top item of stack s</code></p>\n<p>Algorithmically, LIFO tends to happen in the course of executing recursive algorithms.</p>\n<p><strong>Queues</strong>: First in, first out (FIFO) - useful when wanting to reduce maximum time spent waiting (average waiting time is same whether LIFO or FIFO). Trickier to implement -> most appropriate for applications (like certain simulations) where order is important. <em>put</em> and <em>get</em> operations are called 'enqueue' and 'dequeue'\n<code class=\"language-text\">enqueue(x, q) -&gt; insert item x at the back of queue q</code>\n<code class=\"language-text\">dequeue(q) -&gt; return (and remove) front item from queue q</code></p>\n<p>Stacks and queues can be implemented using either arrays or linked lists.</p>\n<h3>Dictionaries:</h3>\n<p>Permits access to data items by content</p>\n<p>Primary operations supported by dictionaries:</p>\n<ul>\n<li>Search(D, k) - Given key k, return pointer to element in dictionary D where key value is k, if exists.</li>\n<li>Insert (D, x) - Given date item x, add to the set in dictionary D.</li>\n<li>Delete (D, x) - Given a pointer to a given data item x in dictionary D, remove it from D</li>\n</ul>\n<p>Some dictionary data structures also support:</p>\n<ul>\n<li>Max(D) or Min(D) - Retrieve item with longest (or smallest) key from D. Enables dictionary to serve as a priority queue.</li>\n<li>Predecessor(D, x) or Successor(D, x) -> retrieve the item from D whose key is immediately before (or after) x in sorted order - enables iterating through elements.</li>\n</ul>\n<p>Many data processing tasks can be handled with dictionaries.</p>\n<p>Ex: Want to remove duplicate names from mailing list and print in sorted order:\nInitiate empty dictionary D whose search key will be record name. Read through mailing list, search to see if in dictionary. If not, insert. When finished, extract remaining names out of dictioanry. Start from first item Min(D) and calling successor until obtain Max(D), traverse all elements in sorted order.</p>\n<p>Running times for fundamental dictionary operations:</p>\n<ul>\n<li>Search -> you test the key against (potentially) each element of an unsorted array, which is linerar as worst case</li>\n<li>Insertion - implemented by incrementing n and copying item to nth cell in the array, leaving bulk of array untouched, so this is constant time</li>\n<li>Deletion - removing the nth element leaves a hole that needs to be filled, which would mean O(n) but you can write over A[x] with A[n] and decrement n, which would be constant time</li>\n<li>Predecessor and Successor -> both require iterating through all elements to determine in an unsorted array</li>\n<li>Min and Max are also defined with respect to sorted order and require linear sweeps to identify in an unsorted array.</li>\n</ul>\n<p>For sorted arrays:</p>\n<ul>\n<li>Searching can be done in O(log n) time using binary search.</li>\n<li>Min/Max, Successor/Predecessor become O(1)</li>\n<li>Insertions and deletions become more expensive (O(n)) because they may result in moving other elements around</li>\n</ul>\n<p><strong>Take Home</strong>: Data structure design must balance all the different operations it supports. The fastest data structure to support both operations A and B may well not be the fastest data structure to support A or B.</p>\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n.tg .tg-0lax{text-align:left;vertical-align:top}\n</style>\n<div class=\"table\">\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-0pky\">Dictionary operation</th>\n    <th class=\"tg-0pky\">Unsorted Array</th>\n    <th class=\"tg-0pky\">Sorted Array</th>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Search (L, k)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(log n)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Insert (L, x)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Delete (L, x)</td>\n    <td class=\"tg-0lax\">O(1)\\*</td>\n    <td class=\"tg-0lax\">O(n)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Successor (L, x) / Predecessor (L, x)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Min (L) / Max (L)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n</table>\n</div>\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n.tg .tg-0lax{text-align:left;vertical-align:top}\n</style>\n<div class=\"table\">\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-0pky\">Dictionary Operation</th>\n    <th class=\"tg-0pky\">Singly Unsorted</th>\n    <th class=\"tg-0pky\">Doubly Unsorted</th>\n    <th class=\"tg-0lax\">Singly Sorted</th>\n    <th class=\"tg-0lax\">Doubly Sorted</th>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Search (L, k)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Insert (L, x)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Delete (L, x)</td>\n    <td class=\"tg-0lax\">O(n)\\*</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(n)\\*</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Successor (L, x)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Predecessor(L, x)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(n)\\*</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Minimum(L)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Maximum(L)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n</table>\n</div>\n<p>Deletion from singly linked list is O(n) because you only have pointer to item to be deleted, so you need to traverse the list to find the previous node in order to update that node's next property - a doubly linked list solves that problem.\nDeleting is faster for sorted linked lists than for sorted arrays because there's no need to move elements around following deletion.</p>\n<p>Searching - sorting is less beneficial for linked lists because you can't implement a binary search due to the inability to randomly access. Linked lists allow you to terminate early when searches are unsuccessful, but worst case is still linear.</p>\n<p>Successor can be implemented in constant time, but predecessor faces the same issue mentioned earlier, having no reference to predecessor, necessitating iteration through list.</p>\n<p>Maximum - max element sits at tail of list which would normally require O(n), but we can maintain a pointer to the list tailk, which can be updated in constant time in doubly linked lists -> on insertion, check fi last->next = NULL and on deletion set last to predecessor of last if last element.</p>\n<p>Maximum can be constant for singly linked lists as well because the charge for deletion is already linear and adding an extra linear pass to update the pointer doesn't harm the asymptotic complexity of delete while it does give us the maximum in constant time.</p>\n<h3>Binary Search Trees</h3>\n<p>Requires fast access to median elements above and below a given node.</p>\n<p><strong>Rooted binary tree</strong>: recursively defined as either being empty or consisting of a node called the root together with two rooted binary trees called the left and right subtrees.</p>\n<p>The order among brother nodes matters in rooted trees such that left is different from right.</p>\n<p><strong>Binary search tree</strong>: labels each node with a single key so that for any node labeled x, all nodes in the left subtree of x have keys &#x3C; x while all nodes in the right subtree of x have keys > x. For any binary tree on n nodes, and any set of n keys, there is <em>one</em> and only one labeling that makes it a binary search tree.</p>\n<p>Binary tree nodes have left and right pointer fields, an optional parent pointer, and a data field.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">tree</span> <span class=\"token punctuation\">{</span>\n    item_type item<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* data item */</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">tree</span> <span class=\"token operator\">*</span>parent<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* pointer to parent */</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">tree</span> <span class=\"token operator\">*</span>left<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* pointer to left child */</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">tree</span> <span class=\"token operator\">*</span>right<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* pointer to right child */</span>\n<span class=\"token punctuation\">}</span> tree<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Basic operations supported by binary trees: searching, traversal, deletion, insertion</p>\n<p><strong>Search in a tree</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">tree <span class=\"token operator\">*</span><span class=\"token function\">search_tree</span><span class=\"token punctuation\">(</span>tree <span class=\"token operator\">*</span>l<span class=\"token punctuation\">,</span> item_type x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>item <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> l<span class=\"token operator\">-></span>item<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span> <span class=\"token function\">search_tree</span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>left<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span> <span class=\"token function\">search_tree</span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>right<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Runs in O(h) time where h denotes the height of the tree.</p>\n<p><strong>Finding maximum and minimum</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">tree <span class=\"token operator\">*</span><span class=\"token function\">find_minimum</span><span class=\"token punctuation\">(</span>tree <span class=\"token operator\">*</span>t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    tree <span class=\"token operator\">*</span>min<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    min <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>min<span class=\"token operator\">-></span>left <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n        min <span class=\"token operator\">=</span> min<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Traverse, visiting nodes recursively in accordance with the policy that all keys smaller than root lie in left subtree of root and all keys bigger than root lie in right subtree, produces an in-order traversal of the search tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">traverse_tree</span><span class=\"token punctuation\">(</span>tree <span class=\"token operator\">*</span>l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">traverse_tree</span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">process_item</span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">traverse_tree</span><span class=\"token punctuation\">(</span>l<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>O(n) traverseal.</p>\n<p>Changing the position of process_item to be before traversing left and right subtrees results in pre-order traversal and moving it to after traversing left and right subtrees results in post-order traversal.</p>\n<p><strong>Insertion</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">insert_tree</span><span class=\"token punctuation\">(</span>tree <span class=\"token operator\">*</span><span class=\"token operator\">*</span>l<span class=\"token punctuation\">,</span> item_type x<span class=\"token punctuation\">,</span> tree <span class=\"token operator\">*</span>parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    tree <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>l <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        p <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* allocate new node */</span>\n        p<span class=\"token operator\">-></span>item <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n        p<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n        p<span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n        <span class=\"token operator\">*</span>l <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* link into parent record */</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>l<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>item<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">insert_tree</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>l<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token function\">insert_tree</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>l<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Insertion is a constant time opreation after the search has been performed in O(h) time.</p>\n<p><strong>Deletion</strong>\nIf node to delete has no children, clear pointer to that node.\nIf node to delete has one child, connect that node's child to its parent.\nIf node to delete has two children, relabel node with the key of its immediate successor in sorted order (leftmost descendant in the right subtree)</p>\n<p>Deletion worst case complexity is O(h) with h being the height of the tree. The height of a tree can range from log n to n dependent on insertion order.</p>\n<p>Random search trees are usually good, but if you're unlucky you can end up with a linear-height tree. You can make a tree that has an insertion/deletion procedure that adjusts the tree to maintain balance (splay trees, red/black trees) so that the height is always O(log n), which is why dictionary operations (insert/delete/query) take O(log n) - because we can assume worst-case complexities of a balanced tree.</p>\n<p><strong>Take Home</strong>: Picking the wrong data structure for the job can be disastrous in terms of performance. Identifying the very best data structure is usually not as critical because there can be several choices that perform similarly.</p>\n<h3>Stop and think: Balanced Search Trees</h3>\n<p><strong>Problem</strong>: You're given the task of reading <em>n</em> numbers and then printing them out in sorted order. Suppoosed you have access to a balanced dictionary data structure, which supports the operations search, insert, delete, minimum, maximum, successor, and predecessor each in O(log n) time.</p>\n<ol>\n<li>How can you sort in O(n log n) time using only insert and in-order traversal?</li>\n<li>How can you sort in O(n log n) time using only minimum, successor, and insert?</li>\n<li>How can you sort in O(n log n) time using only minimum, insert, and delete?</li>\n</ol>\n<p><strong>Solution</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">sort1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">initialize_tree</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>not <span class=\"token constant\">EOF</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Traverse</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">sort2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">initialize_tree</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>not <span class=\"token constant\">EOF</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span>\n    y <span class=\"token operator\">=</span> <span class=\"token function\">Minimum</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>y <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>y<span class=\"token operator\">-></span>item<span class=\"token punctuation\">)</span>\n        y <span class=\"token operator\">=</span> <span class=\"token function\">successor</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">sort3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">initialize_tree</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>not <span class=\"token constant\">EOF</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span>\n    y <span class=\"token operator\">=</span> <span class=\"token function\">Minimum</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>y <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>y<span class=\"token operator\">-></span>item<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">Delete</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">)</span>\n        y <span class=\"token operator\">=</span> <span class=\"token function\">Minimum</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>For the second problem, we start from minimum and repeatedly find successor to traverse the tree in sorted order. For the third problem, we don't have successor, but because we have delete, we can find minimum, print it, delete it, and then call minimum to find the next element.</p>\n<ul>\n<li>Each of the algorithms perform a linear number of logarithmic-time operations, thus O(n log n)</li>\n</ul>\n<h3>Priority Queues:</h3>\n<p>Data structures that provide more flexibility than regular sorting through the ability to add new elements at arbitrary intervals. More cost-effective to insert into priority queue than to re-sort on each new arrival</p>\n<h4>Basic Operations supported by priority queues:</h4>\n<ul>\n<li><em>Insert (Q, x)</em> - Given an item <em>x</em> with key <em>k</em>, insert it into the priority queue <em>Q</em></li>\n<li><em>Find-Minimum(Q)</em> or <em>Find-Maximum(Q)</em> - Return a pointers to the item whose key value is smaller (or larger) than any other key in priority queue <em>Q</em></li>\n<li><em>Delete-Minimum(Q)</em> or <em>Delete-Maximum(Q)</em> - Remove the item from the priority queue <em>Q</em> whose key is minimum(maximum)</li>\n</ul>\n<p><strong>Take Home</strong>: Building algorithms around data structures such as dictionaries and priority queues leads to both clean structure and good performance</p>\n<h3>Stop and Think: Basic Priority Queue Implementation</h3>\n<p><em>Problem</em>: What is the worst-case time complexity of the three basic priority queue operations (insert, find-minimum, delete-minimum) when the basic data structure is:</p>\n<ul>\n<li>an unsorted array</li>\n<li>a sorted array</li>\n<li>a balanced binary search tree</li>\n</ul>\n<p><em>Solution</em>:</p>\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n.tg .tg-0lax{text-align:left;vertical-align:top}\n</style>\n<div class=\"table\">\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-0pky\">Operation</th>\n    <th class=\"tg-0pky\">Unsorted Array</th>\n    <th class=\"tg-0pky\">Sorted Array</th>\n    <th class=\"tg-0pky\">Balanced Tree</th>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Insert(Q, x)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(log n)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Find-Minimum(Q)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Delete-Minimum(Q)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(log n)</td>\n  </tr>\n</table>\n</div>\n<p>Find-Minimum is constant time because you can use an extra pointer to the minimum entry, updating on insertion if the item inserted is less than the current minimum.\nDelete-Minimum's time is based on time it usually takes to perform a search.</p>\n<h3>Hash Tables</h3>\n<p>Practical way to maintain a dictionary as it exploits the fact that looking an item up by index in an array takes constant time. Hash function is a mathematical function that maps keys to integers which are then used as an index into an array.</p>\n<p>Collisions occur when two distinct keys hash to the same value. Chaining is the easiest approach to collision resolution and involves representing the hash table as an array of linked lists where each list represents all the items that hash to that particular index. Takes up a lot of space.</p>\n<p>Alternative: Open addressing -> hash table is maintained as an array of elements initialized to null. On insert, check to see if spot is empty. If empty, place. If taken, find next empty space.</p>\n<ul>\n<li>Deletions with open addressing could break a chain of insertions and make elements inaccessible, so need to reinsert all items in the run following the new hole.</li>\n</ul>\n<p>Chaining and open addressing require O(m) to initialize an m-element hash table to null elements prior to first insertion. Traversing all elements takes O(m + n) for chaining because we have to scan all buckets. Reduces to O(m) for open-addressing because n must be at most m.</p>\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n.tg .tg-0lax{text-align:left;vertical-align:top}\n</style>\n<div class=\"table\">\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-0pky\">Operation</th>\n    <th class=\"tg-0pky\">Hash Table (Expected)</th>\n    <th class=\"tg-0pky\">Hash Table (worst case)</th>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Search(L, k)</td>\n    <td class=\"tg-0lax\">O(n/m)</td>\n    <td class=\"tg-0lax\">O(n)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Insert(L, x)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Delete(L, x)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n    <td class=\"tg-0lax\">O(1)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Successor(L, x)</td>\n    <td class=\"tg-0lax\">O(n+m)</td>\n    <td class=\"tg-0lax\">O(n+m)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Predecessor(L, x)</td>\n    <td class=\"tg-0lax\">O(n+m)</td>\n    <td class=\"tg-0lax\">O(n+m)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Minimum(L)</td>\n    <td class=\"tg-0lax\">O(n+m)</td>\n    <td class=\"tg-0lax\">O(n+m)</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0lax\">Maximum(L)</td>\n    <td class=\"tg-0lax\">O(n+m)</td>\n    <td class=\"tg-0lax\">O(n+m)</td>\n  </tr>\n</table>\n</div>\n<p>Pragmatically, hash tables are often the best data structure to maintain a dictionary.</p>\n<p>Possible to detect duplicates with hash table as two objects of the same content should hash to the same integer - any hash collision with the hash of search term then could be further assessed to check if different.</p>\n<h3>Specialized Data Structures</h3>\n<ul>\n<li><em>String data structures</em>: Character strings are usually represented by arrays of characters. Suffix trees/arrays are special data structures that preprocess strings to make pattern matching operations faster.</li>\n<li><em>Geometric data structures</em>: typically consist of collections of data points and regions. Regions in the plane can be described by polygons where boundary of polygon is given by a chain of line segments. Polygons can be represented using an array of points. Special data structures such as <em>kd-trees</em> organize points and regions by geogmetric location to support fast search.</li>\n<li><em>Graph data structures</em>: usually represented by adjacency matrices or adjacency lists.</li>\n<li><em>Set data structures</em>: Subsets of items typically represented using dictionaries to support fast membership queries. <em>Bit vectors</em> are boolean arrays such that the <em>ith</em> bit represents true if <em>i</em> is in the subset.</li>\n</ul>",
      "frontmatter": {
        "date": "2019-01-13",
        "title": "Algorithm Design Manual:",
        "chapter": "Chapter Three",
        "subtitle": "Data Structures",
        "tags": ["algorithms", "data structures", "Algorithm Design Manual"],
        "path": "/Algorithm-Design-Manual--Chapter-Three"
      }
    }
  },
  "pageContext": {
    "isCreatedByStatefulCreatePages": false,
    "pathSlug": "/Algorithm-Design-Manual--Chapter-Three",
    "prev": {
      "frontmatter": {
        "path": "/Algorithm-Design-Manual--Chapter-Two",
        "title": "Algorithm Design Manual:",
        "tags": ["algorithms", "algorithm analysis", "Algorithm Design Manual"],
        "subtitle": "Algorithm Analysis",
        "chapter": "Chapter Two"
      }
    },
    "next": {
      "frontmatter": {
        "path": "/Algorithm-Design-Manual--Chapter-Four",
        "title": "Algorithm Design Manual:",
        "tags": [
          "algorithms",
          "sorting",
          "searching",
          "Algorithm Design Manual"
        ],
        "subtitle": "Sorting and Searching",
        "chapter": "Chapter Four"
      }
    }
  }
}
