{
  "data": {
    "markdownRemark": {
      "html": "<p>Chapter 5's graph data structure quietly supported edge-weighted graphs, but we'll make it explicit for this chapter. The adjacency list structure consists of an array of linked lists where the outgoing edges from vertex.x appear in the list edges[x]</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    edgenode <span class=\"token operator\">*</span>edges<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* adjacency info */</span>\n    <span class=\"token keyword\">int</span> degree<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* outdegree of each vertex */</span>\n    <span class=\"token keyword\">int</span> nvertices<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of vertices in graph */</span>\n    <span class=\"token keyword\">int</span> nedges<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of edges in graph */</span>\n    <span class=\"token keyword\">int</span> directed<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* is the graph directed? */</span>\n<span class=\"token punctuation\">}</span> graph<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Each edgenode is a record with three fields: first describing second endpoint of the edge (y), second enabling us to annotate the edge with a weight (weight) and third to annotate the next edge in the list (nex):</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* adjacency info */</span>\n    <span class=\"token keyword\">int</span> weight<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* edge weight, if any */</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">edgenode</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* next edge in list */</span>\n<span class=\"token punctuation\">}</span> edgenode<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Minimum Spanning Trees</h3>\n<p>A spanning tree of a graph G = (V, E) is a subset of edges from E forming a tree connecting all vertices of V. For edge-weighted graphs, a tree whose sum of edge weights is as small as possible is a minimum spanning tree. There can be more than one minimum spanning tree in a graph. All spanning trees of an unweighted graph are minimum spanning trees.</p>\n<h3>Prim's Algorithm</h3>\n<p>Starts from one vertex and grows the rest of the tree one edge at a time until all vertices included</p>\n<p>Prim-MST(G)</p>\n<p>    Select an arbitrary vertex s to start the tree from</p>\n<p>    While (therre are still nontree vertices)</p>\n<p>        Select the edge of minimum weight between a tree and nontree vertex</p>\n<p>        Add the selected edge and vertex to the tree T<sub>prim</sub></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">prim</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    edgenode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* temporary pointer */</span>\n    bool intree<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* is the vertex in the tree yet? */</span>\n    <span class=\"token keyword\">int</span> distance<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* cost of adding to tree */</span>\n    <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* current vertex to process */</span>\n    <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* candidate next vertex */</span>\n    <span class=\"token keyword\">int</span> weight<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* edge weight */</span>\n    <span class=\"token keyword\">int</span> dist<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* best current distance from start */</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        intree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False\n        distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> MAXINT<span class=\"token punctuation\">;</span>\n        parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    v <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>intree<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        intree<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token punctuation\">;</span>\n        p <span class=\"token operator\">=</span> g<span class=\"token operator\">-></span>edges<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            w <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>y<span class=\"token punctuation\">;</span>\n            weight <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>weight<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> weight<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>intree<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                distance<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> weight<span class=\"token punctuation\">;</span>\n                parent<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            p <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        v <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        dist <span class=\"token operator\">=</span> MAXINT<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>intree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>dist <span class=\"token operator\">></span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                dist <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                v <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This is an O(n<sup>2</sup>) implementation. Priority-queue data structures lead to an O(m + n lg n) implementation by making it faster to find the minimum cost edge to expand the tree at each iteration.</p>\n<h3>Kruskal's Algorithm</h3>\n<p>Builds up connected components of vertices, culminating in the minimum spanning tree. Initially, each vertex forms its own separate component in the tree to be. The algorithm repeatedly considers the lightest remaining edge and tests whether its two endpoints lie within the same connected component. If so, the edge will be discarded because adding it would create a cycle in the tree to be. If the endpoints are in different components, we insert the edge and merge the two components into one. Since each connected component is always a tree, don't have to test for cycles.</p>\n<p>Kruskal-MST(G)</p>\n<p>    Put the edges in a prirority queue ordered by weight</p>\n<p>    count = 0</p>\n<p>    while (count &#x3C; n-1) do</p>\n<p>        get next edge(v, w)</p>\n<p>        if (component(v) does not equal component(w))</p>\n<p>            Add to T<sub>kruskal</sub></p>\n<p>What is the time complexity?</p>\n<ul>\n<li>Sorting the m edges takes O(m lg m) time</li>\n<li>The for loop makes m iterations, each testing the connectivity of two trees plus an edge. In the most simple-minded approach, this can be implemented by breadth-first or depth-first search in a sparse graph with at most n edges and n vertices, thus yielding an O(mn) algorithm.</li>\n</ul>\n<p>Faster implementation results if we can implement the component test in faster than O(n) time. Union-find is a data structure that can support such queries in O(lg n) time, allowing Kruskal's algorithm to run in O(m lg m) time, faster than Prim's for sparse graphs.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">kruskal</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    set_union s<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* set union data structure */</span>\n    edge_pair e<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* array of edges data structure */</span>\n    bool <span class=\"token function\">weight_compare</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">set_union_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">,</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">to_edge_array</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* sort edges by increasing cost */</span>\n    <span class=\"token function\">qsort</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">,</span> g<span class=\"token operator\">-></span>nedges<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>edge_pair<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> weight_compare<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span>g<span class=\"token operator\">-></span>nedges<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">same_component</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"edge (%d, %d) in MST\\n\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">union_sets</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Union-Find Data Structure</h3>\n<p>A set partition is a partitioning of the elements of some universal set (say integers 1 to n) into a collection of disjointed subsets. Each element must be in exactly one subset.</p>\n<p>The connected components in a graph can be represented as a set partition. For Kruskal's algorithm to run efficiently, we need a data structure that efficiently supports the following operations:</p>\n<ul>\n<li><em>Same component(V<sub>1</sub>, V<sub>2</sub>)</em> - Do vertices V<sub>1</sub> and V<sub>2</sub> occur in the same connected component of the current graph?</li>\n<li><em>Merge components(C<sub>1</sub>, C<sub>2</sub>)</em> - Merge the given pair of connected components into one component in response to an edge between them.</li>\n</ul>\n<p>The union-find data structure represents each subset as a \"backwards\" tree, with pointers from a node to its parent. Each node of this tree contains a set el.ement and the name of the set is taken from the key at the root.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> p<span class=\"token punctuation\">[</span>SET_SIZE<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* parent element */</span>\n    <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">[</span>SET_SIZE<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of elements in subtree */</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of elements in set */</span>\n<span class=\"token punctuation\">}</span> set_union<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We implement desired ops in terms of operations <em>union</em> and <em>find</em>:</p>\n<ul>\n<li><em>Find(i)</em> - Find the root of tree containing element <em>i</em> by walking up the parent pointers until there is nowhere to go. Return the lable of the root.</li>\n<li><em>Union(i, j)</em> - Link the root of one of the trees (say containing i) to the root of the tree containing the other (say j) so <em>find(i)</em> now equals <em>find(j)</em>.</li>\n</ul>\n<p>To minimize tree height, it is better to make the smaller tree the subtree of the larger one. The height of all the nodes in the root subtree stay the same while the height of the nodes merged into the tree all increase by one. Thus, merging in the smaller tree leaves the height unchanged on the larger set of vertices</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">set_union_init</span><span class=\"token punctuation\">(</span>set_union <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        s<span class=\"token operator\">-></span>p<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        s<span class=\"token operator\">-></span>size<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    s<span class=\"token operator\">-></span>n <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>set_union <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>p<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> s<span class=\"token operator\">-></span>p<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">union_sets</span><span class=\"token punctuation\">(</span>set_union <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> s1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> s2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> r1<span class=\"token punctuation\">,</span> r2<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* roots of sets */</span>\n    r1 <span class=\"token operator\">=</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    r2 <span class=\"token operator\">=</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>r1 <span class=\"token operator\">==</span> r2<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* already in same set */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">-></span>size<span class=\"token punctuation\">[</span>r1<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> s<span class=\"token operator\">-></span>size<span class=\"token punctuation\">[</span>r2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        s<span class=\"token operator\">-></span>size<span class=\"token punctuation\">[</span>r1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> s<span class=\"token operator\">-></span>size<span class=\"token punctuation\">[</span>r1<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> s<span class=\"token operator\">-></span>size<span class=\"token punctuation\">[</span>r2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        s<span class=\"token operator\">-></span>p<span class=\"token punctuation\">[</span>r2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> r1<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        s<span class=\"token operator\">-></span>size<span class=\"token punctuation\">[</span>r2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> s<span class=\"token operator\">-></span>size<span class=\"token punctuation\">[</span>r1<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> s<span class=\"token operator\">-></span>size<span class=\"token punctuation\">[</span>r2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        s<span class=\"token operator\">-></span>p<span class=\"token punctuation\">[</span>r1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> r2<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nbool <span class=\"token function\">same_component</span><span class=\"token punctuation\">(</span>set_union <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> s1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> s2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>On each union, the tree with fewer nodes becomes the child. Only when merging two height 2 trees do we get a tree of height 3 (now with four nodes). At most, we can do lg<sub>2</sub>n doublings to use up all n nodes, so we can do both unions and finds in O(log n) time.</p>\n<h3>Variations on Minimum Spanning Trees</h3>\n<ul>\n<li><em>Maximum Spanning Trees</em> - The maximum spanning tree of any graph can be found by simply negating the weights of all edges and running Prim's algorithm. The most negative tree in the negated graph is the maximum spanning tree in the original. Most graph algorithms do not adapt so easily to negative numbers.</li>\n<li><em>Minimum Product Spanning Trees</em> - Since lg(a <sup>.</sup> b) = lg(a) + lg(b), the minimum spanning tree on a graph whose edge weights are replaced with their logarithms gives the minimum product spanning tree on the original graph</li>\n<li><em>Minimum Bottleneck Spanning Tree</em> - Tree that minimizes the maximum edge weight over all trees</li>\n</ul>\n<p>The minimum spanning tree of a graph is unique if all m edge weights in the graph are distinct. Otherwise, the way Prim's/Kruskal's algorithms break ties determines which minimum spanning tree is returned.</p>\n<p>Two variants of minimum spanning tree not solvable with these techniques:</p>\n<ul>\n<li><em>Steiner tree</em> - If you want to wire a bunch of houses together but have the freedom to add extra intermediate vertices to serve as a shared junction</li>\n<li><em>Low-degree Spanning Tree</em> - If you want to find the minimum spanning tree where the highest degree node in the tree is small. The lowest max-degree tree possible would be a simple path and have n-2 nodes of degree 2 with two endpoints of degree 1. A path that visits each vertex once is called a Hamiltonian path.</li>\n</ul>\n<h3>Shortest Paths</h3>\n<p>A path is a sequence of edges connecting two vertices. The shortest path from <em>s</em> to <em>t</em> in an unweighted graph can be constructed using a breadth-first search from <em>s</em>.</p>\n<h3>Dijkstra's Algorithm</h3>\n<p>The method of choice for finding the shortest path in an edge and/or vertex-weighted graph. Given a particular start vertex <em>s</em>, it finds the shortest path from <em>s</em> to every other vertex in the graph, including your desired destination <em>A</em>.</p>\n<p>Dijkstra's Algorithm proceeds in a series of rounds where each round establishes the shortest path from <em>s</em> to some new vertex. Specifically, <em>x</em> is the vertex that minimizes the <em>dist(s, v<sub>1</sub>) + w(v<sub>1</sub>, x)</em> over all unfinished 1 ≤ <em>i</em> ≤ <em>n</em> where <em>w(i, j)</em> is the length of the edge from <em>i</em> to <em>j</em> and <em>dist(i, j)</em> is the length of the shortest path between them.</p>\n<p>ShortestPath-Dijkstra(G, s, t)</p>\n<p>    known = {s)</p>\n<p>     for i = 1 to n, dist[i] = infinity</p>\n<p>     for each edge (s, v), dist[v] = w(s, v)</p>\n<p>     last = s</p>\n<p>    while (last does not equal t)</p>\n<p>        select v<sub>next</sub>, the unkonwn vertex minimizing dist[v]</p>\n<p>        for each edge(v<sub>next, x), dist[x] = min[dist[x], dist[v<sub>next</sub>] + w(v<sub>next</sub>, x)]</p>\n<p>        last = v<sub>next</sub></p>\n<p>        known = known U {v<sub>next</sub>}</p>\n<p>In each iteration, we add one vertex to the tree of vertices for which we know the shortest path from <em>s</em>. We keep track of best path seen for all vertices outside the tree and insert them in order of increasing cost.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    edgenode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* temporary pointer */</span>\n    bool intree<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* is the vertex in the tree yet? */</span>\n    <span class=\"token keyword\">int</span> distance<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* distance vertex is from start */</span>\n    <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* current vertex to process */</span>\n    <span class=\"token keyword\">int</span> w<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* candidate next vertex */</span>\n    <span class=\"token keyword\">int</span> weight<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* edge weight */</span>\n    <span class=\"token keyword\">int</span> dist<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* best current distance from start */</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        intree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False<span class=\"token punctuation\">;</span>\n        distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> MAXINT<span class=\"token punctuation\">;</span>\n        parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    v <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>intree<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        intree<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True\n        p <span class=\"token operator\">=</span> g<span class=\"token operator\">-></span>edges<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            w <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>y<span class=\"token punctuation\">;</span>\n            weight <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>weight<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                distance<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> weight<span class=\"token punctuation\">;</span>\n                parent<span class=\"token punctuation\">[</span>w<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            p <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        v <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        dist <span class=\"token operator\">=</span> MAXINT<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>intree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>dist <span class=\"token operator\">></span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                dist <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                v <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Finds more than shortest path, from <em>s</em> to <em>t</em>, finds the shortest path from <em>s</em> to all other vertices. Dijkstra works correctly only on graphs without negative-cost edges.</p>\n<p>As implemented, the run-time complexity is (On<sup>2</sup>). The length of the shortest path from start to a given vertex <em>t</em> is exactly the value of distance[t]. To find the actual path, we follow the backward parent pointers from <em>t</em> until we hit start (or -1 if no such path exists)</p>\n<h3>Stop and Think: Shortest Path with Node Costs</h3>\n<p><em>Problem</em>: We are given a graph whose weights are on the vertices instead of the edges. Thus, the cost of a path from <em>x</em> to <em>y</em> is the sum of the weights of all vertices on the path.</p>\n<p>Give an efficient algorithm for finding the shortest paths.</p>\n<p><em>Solution</em>: You could modify Dijkstra by replacing all references to the weight of an edge with the weight of the destination vertex, which can be looked up as needed from an array of vertex weights.</p>\n<p>You could also opt to leave Dijkstra intact and construct an edge-weighted graph on which Dijkstra will give a desired answer. Set the weight of each directed edge (i, j) in the input graph to the cost of vertex j.</p>\n<h3>All-Pairs Shortest Path</h3>\n<p>Floyd's all-pairs shortest-path algorithm is a slick way to create a nxn distance matrix from the origiinal weight matrix of the graph</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> weight<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* adjacency/weight info */</span>\n    <span class=\"token keyword\">int</span> nvertices<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of vertices in the graph */</span>\n<span class=\"token punctuation\">}</span> adjacency_matrix<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We should initialize each non-edge to MAXINT. This way, we can test whether it is present and automatically ignore it in shortest-path computations since only real edges will be used, provided MAXINT is greater than the diameter of your graph. <em>Diameter</em> being the longest shortest-path distance over all pairs of vertices.</p>\n<p>There are several ways to characterize the shortest path between two nodes in a graph. The Floyd-Warshall algorithm starts by numbering the vertices of the graph from 1 to <em>n</em>. We use the numbers not to label vertices but to order them. When k=0, we are allowed no intermediate vertices, so the only allowed paths are the original edges on the graph. Thus the initial all-pairs shortest-path matrix consists of the initial adjacency matrix. We perform n iterations where the <em>kth</em> iteration allows only the first <em>k</em> vertices as possible intermediate steps on the path between each pair of vertices <em>x</em> and <em>y</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">floyd</span><span class=\"token punctuation\">(</span>adjacency_matrix <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* dimension counters */</span>\n    <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* intedrmediate vertex counter */</span>\n    <span class=\"token keyword\">int</span> through_k<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* distance through vertex */</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                through_k <span class=\"token operator\">=</span> g<span class=\"token operator\">-></span>weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> g<span class=\"token operator\">-></span>weight<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>through_k <span class=\"token operator\">&lt;</span> g<span class=\"token operator\">-></span>weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    g<span class=\"token operator\">-></span>weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> through_k<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Floyd-Warshall all-pairs shortest-path runs in O(n<sup>3</sup>) time which is asymptotically no better than <em>n</em> calls to Dijkstra's algorithm, but the loops are so tight and program so short that it runs better in practice. It is one of the rare graph algorithms that works better on adjacency matrixes than adjacency lists.</p>\n<p>Output of Floyd's algorithm does not enable the reconstruction of the actual path between any given pair of vertices, but these paths can be recovered if we retain a parent matrix <em>P</em> of the last intermediate vertex used for each vertex pair (x, y). If the value is <em>k</em>, the shortest path from <em>x</em> to <em>y</em> is the concatenation of the shortest path from <em>x</em> to <em>k</em> and the shortest path from <em>k</em> to <em>y</em>, whcih can be reconstructed recursively given matrix <em>P</em>.</p>\n<h3>Transitive Closure:</h3>\n<p><em>Blackmail graph</em>: There is a directed edge (i, j) if person <em>i</em> has sensitive-enough private information on person <em>j</em> so that <em>i</em> can get <em>j</em> to do anything he wants. You want to hire one of the <em>n</em> people to be your personal representative. Who has the most power in terms of blackmail potential?</p>\n<p>Simple answer would be vertex of highest degree. But if Steve can only blackmail Miguel and Miguel can blackmail everybody else, you want to hire Steve.</p>\n<h3>Network Flows and Bipartite Matching</h3>\n<p>Edge-weighted graphs can be interpreted as a network of pipes where the weight of edge (i,j) determines the capacity of the pipe. Capacities can be thoguht of as a function of the cross-sectional area of the pipe. A wide pipe might be able to carry 10 units of flow at a time whereas a narrower pipe may only be able to carry 5 units. The network flow problem asks for the maximum amount of flow which can be sent from vertices <em>s</em> to <em>t</em> in a given weighted graph <em>G</em> while respecting the maximum capacities of each pipe.</p>\n<h3>Bipartite Matching</h3>\n<p>A <em>matching</em> in a graph <em>G = (V, E)</em> is a subset of edges E' ⸦ E such that no two Edges of E' share a vertex. A matching pairs off certain vertices such that every vertex is in, at most, one such pair.</p>\n<p>Graph <em>G</em> is bipartite or <em>two-colorable</em> if the vertices can be divided into two sets, <em>L</em> and <em>R</em> such that all edges in <em>G</em> have one vertex in <em>L</em> and one vertex in <em>R</em>.</p>\n<p>The largest bipartite matching can be found using network flow. Create a source node <em>s</em> that is connected to every vertex in <em>L</em> by an edge of weight 1. Create a sink node <em>t</em> and connect it to every vertex in <em>R</em> by an edge of weight 1. Assign each edge in the bipartite graph <em>G</em> a weight of 1. The maximum flow <em>s</em> to <em>t</em> defines the largest matching in <em>G</em>.</p>\n<h3>Computing Network Flows</h3>\n<p>It can be shown that the flow through a network is optimal if and only if it contains no <em>augmenting path</em>. Since each augmentation adds to the flow, we must eventually find the global maximum.</p>\n<p>The key structure is the residual flow graph, denoted as <em>R(G, f)</em> where <em>G</em> is the input graph and <em>f</em> is the current flow through <em>G</em>.</p>\n<p>This directed edge-weighted <em>R(G, f)</em> contains the same vertices as <em>G</em>. For each edge (i, j) is <em>G</em> with capacity <em>c(i, j)</em> and flow <em>f(i, j)</em>. <em>R(G, f)</em> may contain two edges: <br/>\n(i) an edge <em>(i, j)</em> with weight <em>c(i, j) - f(i, j)</em>, if <em>c(i, j) - f(i, j)</em> > 0 and <br/>\n(ii) an edge <em>(j, i)</em> with weight <em>f(i, j)</em>, if <em>f(i, j)</em> > 0</p>\n<p>The prescence of edge (i, j) in the residual graph indicates that positive flow can be pushed from <em>i</em> to <em>j</em>. The weight of the edge gives the exact amount that can be pushed. A path in the residual graph from <em>s</em> to <em>t</em> implies that more flow can be pushed from <em>s</em> to <em>t</em> and the minimum edge weight on the path defines the amount of extra flow that can be pushed.</p>\n<h3>Take Home:</h3>\n<p>The maximum flow from <em>s</em> to <em>t</em> always equals the weight of the minimum s-t cut. Thus, flow algorithms can be used to solve general edge and vertex connectivity problems in graphs.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* neighboring vertex */</span>\n    <span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* capacity of edge */</span>\n    <span class=\"token keyword\">int</span> flow<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* flow through edge */</span>\n    <span class=\"token keyword\">int</span> residual<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* residual capacity of edge */</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">edgenode</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* next edge in list */</span>\n<span class=\"token punctuation\">}</span> edgenode<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We use breadth-first search to look for any path from source to sink that increases the total flow, and use it to augment the total. We terminate with the optimal flow when no such augmenting path exists.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">netflow</span><span class=\"token punctuation\">(</span>flow_graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> source<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> sink<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> volume<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* weight of the augmenting path */</span>\n    <span class=\"token function\">add_residual_edges</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">initialize_search</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    volume <span class=\"token operator\">=</span> <span class=\"token function\">path_volume</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">,</span> sink<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>volume <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">augment_path</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">,</span> sink<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">,</span> volume<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">initialize_search</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        volume <span class=\"token operator\">=</span> <span class=\"token function\">path_volume</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">,</span> sink<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Any augmenting path from source to sink increases the flow, so we can use bfs to find such a path in the appropriate graph. We only consider network edges that have remaining capacity (positive residual flow). This helps bfs distinguish between saturated and unsaturated edges.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">bool <span class=\"token function\">valid_edge</span><span class=\"token punctuation\">(</span>edgenode <span class=\"token operator\">*</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">-></span>residual <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> true<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> false<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Augmenting a path transfers the maximum possible volume from the residual capacity into positive flow. This amount is limited by the path-edge with the smallest amount of residual capacity just as the rate of which traffic can flow is limited by the most congested point.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">path_volume</span><span class=\"token punctuation\">(</span>flow_graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> parents<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    edgenode <span class=\"token operator\">*</span>e<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* edge in question */</span>\n    edgenode <span class=\"token operator\">*</span><span class=\"token function\">find_edge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parents<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    e <span class=\"token operator\">=</span> <span class=\"token function\">find_edge</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> parents<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">==</span> parents<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> e<span class=\"token operator\">-></span>residual<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>min <span class=\"token punctuation\">(</span><span class=\"token function\">path_volume</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> parents<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> parents<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> e<span class=\"token operator\">-></span>residual<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nedgenode <span class=\"token operator\">*</span><span class=\"token function\">find_edge</span><span class=\"token punctuation\">(</span>flow_graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    edgenode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* temporary pointer */</span>\n    p <span class=\"token operator\">=</span> g<span class=\"token operator\">-></span>edges<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>v <span class=\"token operator\">==</span> y<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span>\n        p <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Sending an additional unit of flow along directed edge (i, j) reduces the residual capacity of edge (i, j) but increases the residual capacity of edge (j, i). Thus, the act of augmenting a path requires modifying both forward and reverse edges for each link on the path.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">augment_path</span><span class=\"token punctuation\">(</span>flow_graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> parents<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> volume<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    edgenode <span class=\"token operator\">*</span>e<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* edge in question */</span>\n    edgenode <span class=\"token operator\">*</span><span class=\"token function\">find_edge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">==</span> end<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    e <span class=\"token operator\">=</span> <span class=\"token function\">find_edge</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> parents<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    e<span class=\"token operator\">-></span>flow <span class=\"token operator\">+=</span> volume<span class=\"token punctuation\">;</span>\n    e<span class=\"token operator\">-></span>residual <span class=\"token operator\">-=</span> volume<span class=\"token punctuation\">;</span>\n    e <span class=\"token operator\">=</span> <span class=\"token function\">find_edge</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> parents<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    e<span class=\"token operator\">-></span>residual <span class=\"token operator\">+=</span> volume<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">augment_path</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> parents<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> parents<span class=\"token punctuation\">,</span> volume<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Initializing the graph requires creating directed flow edges (i, j) and (j, i) for each network edge e = (i, j). Initial flows are set to 0. The initial residual flows of (i, j) is set to the capacity of e, while the initial flow of (j, i) is set to 0.</p>\n<h3>Design Graphs, not Algorithms</h3>\n<p>The secret is learning to design graphs, not algorithms</p>\n<ul>\n<li>The maximum spanning tree can be found by negating the edge weights of input graph <em>G</em> and using a minimum spanning tree algorithm in the result. The most negative weight spanning tree is the maximum weight tree in <em>G</em>.</li>\n<li>To solve bipartite matching, we can construct a special network flow graph such that the maximum flow corresponds to a maximum cardinality matching.</li>\n</ul>\n<h3>Stop and Think: The Pink Panther's Passport in Peril</h3>\n<p><em>Problem</em>: Algorithm to design natural routes for video game characters to follow through obstacle-filled rooms\n<em>Solution</em>: In trying to create natural paths, we would mimic actions of intelligent beings, which move lazily and/or efficiently. This lends to shortest path problem. Could lay out a grid of points in the room and create vertexes for each grid point valid for character movement (i.e., not containing an obstacle).</p>\n<h3>Sotp and Think: Ordering the Sequence:</h3>\n<p><em>Problem</em>: DNA sequencing separates data consisting of small fragments where we know certain fragments lie to the left of a given fragment and others lie to the right of a given fragment - How can we find a consistent ordering of the fragments from left to right?</p>\n<p><em>Solution</em>: Create directed graph. Each fragment assigned a unique vertex. Insert directed edge <em>(l, f)</em> from any fragment <em>l</em> that is forced to be to the left of <em>f</em> and a directed edge <em>(f, r)</em> to any fragment <em>r</em> forced to be to the right of <em>f</em>.</p>\n<h3>Stop and Think: Bucketing Rectangles</h3>\n<p><em>Problem</em>: Given an arbitrary set of rectangles on a plane, how can you distribute them into a minimum number of buckets such that no subset of rectangles in any given bucket intersects another?</p>\n<p><em>Solution</em>: Graph. Each vertex is a rectangle- edge if rectangles intersect. Each bucket is an independent set of rectangles so no overlap between any two.</p>\n<h3>Stop and Think: Names in Collision</h3>\n<p><em>Problem</em>: How can you meaningfully shorten filenames so they don't collide?</p>\n<p><em>Solution</em>: Bipartite graph with vertices corresponding to original file names and a collection of appropriate shortenings for each name. Add edge between original and shortened name. Look for a set of <em>n</em> edges that have no vertices in common</p>\n<h3>Stop and Think: Separate the Text</h3>\n<p><em>Problem</em>: How do we do line segmentation?</p>\n<p><em>Solution</em>: Treat each pixel in the image as a vertex in the graph with edge between neighboring pixels. Weight of edges should be proportioned to how dark the pixels are. Seek a relatively straight path that avoids as much blackness as possible.</p>\n<h3>Take Home:</h3>\n<p>Designing novel graph algorithms is very hard, so don't do it. Instead, try to design graphs that enable you to use classical algorithms to model your problem.</p>",
      "frontmatter": {
        "date": "2019-01-18",
        "title": "Algorithm Design Manual:",
        "chapter": "Chapter Six",
        "subtitle": "Weighted Graph Algorithms",
        "tags": ["algorithms", "graphs", "Algorithm Design Manual"],
        "path": "/Algorithm-Design-Manual--Chapter-Six"
      }
    }
  },
  "pageContext": {
    "isCreatedByStatefulCreatePages": false,
    "pathSlug": "/Algorithm-Design-Manual--Chapter-Six",
    "prev": {
      "frontmatter": {
        "path": "/Algorithm-Design-Manual--Chapter-Five",
        "title": "Algorithm Design Manual:",
        "tags": ["algorithms", "graphs", "Algorithm Design Manual"],
        "subtitle": "Graph Traversal",
        "chapter": "Chapter Five"
      }
    },
    "next": {
      "frontmatter": {
        "path": "/Algorithm-Design-Manual--Chapter-Seven",
        "title": "Algorithm Design Manual:",
        "tags": [
          "algorithms",
          "heuristics",
          "search",
          "Algorithm Design Manual"
        ],
        "subtitle": "Combinatorial Search and Heuristic Methods",
        "chapter": "Chapter Seven"
      }
    }
  }
}
