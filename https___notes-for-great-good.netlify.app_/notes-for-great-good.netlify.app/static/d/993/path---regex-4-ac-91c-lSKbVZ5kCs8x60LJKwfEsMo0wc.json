{
  "data": {
    "markdownRemark": {
      "html": "<p><code class=\"language-text\">myRegex = /Hello/</code> &#x3C;- literal string!\n<code class=\"language-text\">myString = &quot;Hello, world&quot;</code>\n<code class=\"language-text\">myRegex.test(myString)</code></p>\n<h3>test () checks if string contains something matching regex and returns true or false</h3>\n<p><code class=\"language-text\">|</code> &#x3C;--- pipe (can be used for 'or')</p>\n<h3>Flags</h3>\n<p>Appended to regex to modify rules\n<code class=\"language-text\">i</code> = ignore case/case insensitive\n<code class=\"language-text\">g</code> = global (to search for pattern more than once)</p>\n<h3>Match</h3>\n<p>Extracts matches found in regex</p>\n<p><code class=\"language-text\">myString.match(myRegex)</code></p>\n<h3>. (dot) - Wildcard!</h3>\n<p><code class=\"language-text\">.</code> &#x3C;--- period/dot = matches any one character</p>\n<h2>Character Sets</h2>\n<p>When you want to have several options for a character (like 'or')\nExample:\n<code class=\"language-text\">/b[aiu]g/</code> would match bag, big, and bug\nInside character set, you can use a hyphen to define a range</p>\n<h2>Negated Set</h2>\n<p>Match anything other than defined (use carat ^)\nExample:\n<code class=\"language-text\">/[^aeiou]/gi</code> matches anything not a vowel</p>\n<h3>+</h3>\n<p>To match a character or group of characters that appear one or more times in a row, use <code class=\"language-text\">+</code>\nExample:\n<code class=\"language-text\">/a+/g</code> would return 'a' for 'abc', 'aa', for 'aabc', 'a' for 'abab' and no match for 'bed'</p>\n<h3>_ (Asterisk)</h3>\n<p>To match zero or more occurrences, use _</p>\n<p>Note to future self: Regex is character by character. If you see <code class=\"language-text\">/an*/ig</code>, that's really saying \"look for a and it may or may not be followed by an 'n'\" - works like a wildcard\nAsterisk can be used on character sets unlike wildcard dot (which only works iwth a single character)</p>\n<h2>Greedy match:</h2>\n<p>Longest possible match (default for regular expressions)</p>\n<h2>Lazy match:</h2>\n<p>Smallest possible part that satisfies regex pattern</p>\n<p>Example:\n<code class=\"language-text\">myString = &quot;titantic&quot;</code>\n<code class=\"language-text\">myRegex = /t[a-z]*i/</code> would return \"titanti\"\n<code class=\"language-text\">myRegex = /t[a-z]*?i/</code> would return \"ti\"</p>\n<h2>$ (Anchor):</h2>\n<p>Anchor character searches for pattern at the end of a string.</p>\n<h2>Shorthand Character Classes:</h2>\n<p><code class=\"language-text\">\\w</code> is a shorthand equivalent to <code class=\"language-text\">[A-Za-z0-9_]</code>\n<code class=\"language-text\">\\W</code> is shorthand equivalent to <code class=\"language-text\">[^A-Za-z0-9_]</code>\n<code class=\"language-text\">\\d</code> is shorthand equivalent to <code class=\"language-text\">[0-9]</code>\n<code class=\"language-text\">\\D</code> is shorthand equivalent to <code class=\"language-text\">[^0-0]</code>\n<code class=\"language-text\">\\s</code> matches whitespace, carriage return, tab, form feed, newline - similar to <code class=\"language-text\">[\\r\\t\\f\\n\\v]</code>\n<code class=\"language-text\">\\S</code> is similar to <code class=\"language-text\">[^\\r\\t\\f\\n\\v]</code></p>\n<h2>Quantity Specifiers:</h2>\n<p>Range of repeat characters {num1, num2}\nExample:\n// match only if letter 'a' appears between 3 and 5 times in 'ah'\n<code class=\"language-text\">myRegex = /a{3, 5}h/</code></p>\n<p>To specify only lower limit, {num, }\nTo specify the exact number of matches, {num}</p>\n<h3>?</h3>\n<p>To check for zero or more of a character</p>\n<h2>Lookaheads:</h2>\n<p>Checks to see if something is there, but doesn't match it.</p>\n<h3>Positive Lookahead (?= char):</h3>\n<p>Checks that an element is there</p>\n<h3>Negative Lookahead (?! char):</h3>\n<p>Checks that an element is not there</p>\n<h2>Capture Group:</h2>\n<p>Things in parentheses.\nEach capture group is numbered and can follow them with their number to indicate placement (so the number becomes like a variable reference).\nExample:\n<code class=\"language-text\">/(waka) \\1 \\1 \\1 sometimes maybe/gi</code> matches:\n\"waka waka waka waka sometimes maybe\"</p>",
      "frontmatter": {
        "date": "2018-08-01",
        "title": "Regex",
        "chapter": null,
        "subtitle": null,
        "tags": ["regex", "theory of computation"],
        "path": "/Regex"
      }
    }
  },
  "pageContext": {
    "isCreatedByStatefulCreatePages": false,
    "pathSlug": "/Regex",
    "prev": {
      "frontmatter": {
        "path": "/Intro-to-Security-and-Cryptography",
        "title": "Lambda School: Introduction to Security & Cryptography",
        "tags": ["security", "cryptography"],
        "subtitle": null,
        "chapter": null
      }
    },
    "next": {
      "frontmatter": {
        "path": "/State-Machines",
        "title": "State Machines",
        "tags": ["state machines", "theory of computation"],
        "subtitle": null,
        "chapter": null
      }
    }
  }
}
