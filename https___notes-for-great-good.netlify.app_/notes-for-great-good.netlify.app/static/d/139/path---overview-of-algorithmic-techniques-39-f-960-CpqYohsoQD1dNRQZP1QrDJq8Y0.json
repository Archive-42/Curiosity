{
  "data": {
    "markdownRemark": {
      "html": "<h2>Algorithms:</h2>\n<p>Something that gives you a recipe step by step to solve some type of problem.</p>\n<h2>Connection between Algorithms and Data Structures:</h2>\n<p>Algorithsm have data structures underneath them to make them go.</p>\n<h2>Big O is a measure of runtime efficiency</h2>\n<h3>O(1): Constant time</h3>\n<p>\"Free\"</p>\n<h3>O(log n): Logarithmic</h3>\n<p>Tree is an example\nA tree has many more nodes than it has layers\nlog does not grow very fast</p>\n<h3>O(n): Linear</h3>\n<p>Linked list is an example\nScalable and often as good as it can get for any problem that requires you to look at every input once</p>\n<h3>O (n log n): Log linear/linearithmic</h3>\n<p>Log term * log term\nNot much worse than linear</p>\n<h3>O(n^2) Quadratic:</h3>\n<p>Nested for loops is an example</p>\n<p>An efficient algorithm can be the difference between something that runs and completes versus something that explodes and couldn't run even if you had a computer the size of the universe.</p>\n<h2>One good algorithmic tool in toolkit:</h2>\n<h3>Greedy algorithm:</h3>\n<ul>\n<li>Each step of the algorithm does one simple thing satisfying a greedy heuristic</li>\n<li>Looks at options immediately available to it and picks one</li>\n<li>Iterates, adding the next piece of data and does that until it goes through all the data</li>\n<li>If it's correct, it gets the right answer to the question</li>\n<li>If you're lucky, it can be efficient or optimal</li>\n<li>Idea of greedy algorithm/heuristic related to brute force and naive</li>\n</ul>\n<h4>Example:</h4>\n<p>Prim's algorithm <a href=\"https://visualgo.net/en/mst?slide=1\">https://visualgo.net/en/mst?slide=1</a></p>\n<ul>\n<li>Finds minimum spanning tree for a weighted undirected graph</li>\n<li>Graph is a collection of vertices and edges between them</li>\n<li>Weighted, edges have some number that means their cost</li>\n<li>Undirected because edges are the same</li>\n<li>Minimum spanning tree - collection of edges that connect all the vertices at minimum total cost if you add up the numbers associated with all the edges</li>\n<li>Start by choosing vertex arbitrarily</li>\n<li>Output needs to connect all the vertices so you can start anywhere</li>\n<li>Add edges that we can consider next</li>\n<li>Priority queue</li>\n<li>Logarithmic in operation</li>\n<li>Data structure efficient at finding the minimum</li>\n<li>Natural for Prim's</li>\n<li>Add edges to the priority queue</li>\n<li>As long as priority queue is not empty, find cheapest edge in the priority queue</li>\n<li>Add vertex that that edge connects you to if not already connected</li>\n<li>Add all edges you can now reach as a result of that vertex</li>\n<li>Repeat</li>\n<li>Check every edge</li>\n</ul>\n<h3>Divide and conquer:</h3>\n<ul>\n<li>\n<p>Each step of the algorithm either solves a small piece (base case) or puts together two small solutions into a larger solution.</p>\n</li>\n<li>\n<p>(log n) situation</p>\n</li>\n<li>\n<p>For sorting algorithms, log linear is common (best you can do with comparison-based sorts)</p>\n</li>\n<li>\n<p>What is a base case of sorting? Single item.</p>\n</li>\n<li>\n<p>How can we efficiently combine base cases? If you have two lists you know are sorted, you can interate linearly comparing the first element and whatever's smaller is the first element of the combined list, repeat</p>\n</li>\n</ul>\n<h4>Merge sort:</h4>\n<p><a href=\"https://visualgo.net/bn/sorting?slide=10\">https://visualgo.net/bn/sorting?slide=10</a></p>\n<h4>Quicksort:</h4>\n<p>Natural evolution of merge sort\nFast sort that is often used in places where performance matters\nIn-place sorting\nNot a stable sort\nPivot\nIf you're deterministic in how you pick which of your elements to pivot around, for some inputs you'll be quaddratic\nRandomized quicksort\nPicks pivot randomly</p>\n<h4>Bubblesort</h4>\n<p>Quaddratic\nFun to learn, joke to use</p>\n<p>There are some situations where being random is best\nQuicksort is a case where random is cheap, easy, and efficient</p>\n<h3>Dynamic Programming:</h3>\n<ul>\n<li>Optimization technique</li>\n<li>Remember things cleverly (memoization)</li>\n<li>Divide into subproblems but subproblems depend on each other and can be used to solve one another</li>\n<li>Because you're saving data, you have a space-performance tradeoff</li>\n<li>Often a good trade to make, but there are some situations where that can limit what you can do with dynamic programming</li>\n</ul>\n<h4>Counter example of dynamic programming</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fib</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Not dynamic yet:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fib</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> fibs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fibbs<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>fibbs<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> fibbs<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>With memoization:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> fibbs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fib</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token keyword\">in</span> fibbs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> fibbs<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    fibbs<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Still recursive, but not redundant</p>\n<h3>How to think algorithmically:</h3>\n<p>No silver bullet, objectively good answer</p>\n<h4>Step 1:</h4>\n<p>Make sure you know and clearly define what the input and output is\nAsk what data structure is natural for that input/output</p>\n<h4>Step 2:</h4>\n<p>Sketch in pseudocode\nNot programming langauge\nDescribe with the same sort of keywords and structures you'd use in a programming language what you'd do to solve the problem</p>\n<h4>Step 3:</h4>\n<p>Code up actual working prototypes</p>\n<h4>Step 4:</h4>\n<p>Test data to test correctness\nIf algorithm isn't correct, probably don't want to use it</p>\n<h4>Exception:</h4>\n<p>Approximation algorithms\nTraveling salesman\nNP-hard/NP-complete\nAlgorithm don't give a solution that's fully correct but close enough with some confidence\nDon't need to worry about directly, but should know it exists\nSmall test cases\nOne bigger test case</p>\n<h4>Step 5:</h4>\n<p>Pick any solution that you can put together to show that the problem is solvable\nOften first workable solution will be greedy</p>\n<p>What if you can think of the problem as bags of smaller indepdent problems similar to each other?\nMight want to try recursing and see if divide and conquer approach works\nThink about an efficient way to combine the solutions but problems themselves are independent and can be solved on their own</p>\n<p>What if you can think of the problem as a sequence of smaller to large problems and as the problems grow, they're harder but can use the solutions from the previous problems?\nDyanmic programming</p>\n<p>Not every problem you face will naturally fit in one of these, but try to keep your eye out and be creative, think about the data structures involved.</p>\n<p>Second goal besides correctness is efficiency\nCode works, now you want to see if you can make it better\nOne of the main places to look is anywhere you iterate</p>\n<p>\"Are there any redundancies?\"\nLook at nested iteration\n\"Do I really need to do this? Could I save something from a different part of the algorithm and use it here?\"</p>\n<p>You will likely be working with high-level programs:\nJavascript, Python, etc.\nIteration not always explicit\nHigher order functions:\nmap, reduce\nlist comprehensions in Python\nYou might have nested or quaddratic features in your code</p>\n<h3>General comment:</h3>\n<p>It's a little more expensive in high-level languages because they're checking bounds and seeing if things exist</p>\n<h3>In C, it's just changing pointers:</h3>\n<p>Really cheap, really fast, potentially really dangerous\nDifference won't matter to you most of the time, but matters for things like math libraries (which is why they're written in C and Fortran)\nMight be using the library wrapped in Python code, but the math might be done in C.</p>\n<h3>Efficiency:</h3>\n<p>Not just about for loops\nCan also have to do with constants\nBig O says to ignore constants\nWhen you initially try to solve the problem, it matters more what class you end up in overall complexity\nOnce you have a soluiton, might be worth it looking at constants\nNever start by optimizing constants\nIf you're in a situation where you're paying for your compute (working on the cloud) and you can change a constant from 1 to a half, you could cut your compute bill in half</p>\n<h3>Overall goal when doing algorithmic problem solving:</h3>\n<p>Find the input/output\nThink about the data structure\nTry your tools\nTest for correctness\nThink about scalability and efficiency</p>\n<h3>Closing comments about algorithms in general:</h3>\n<p>Familiarize yourselves with what data structures are out there (since they are connected)\nSet is an unordered collection of unique elements\nConstant time to check presence for something in a set\nLike keys in a hash table\nAlmost all good python code uses dicts\nBe aware of what structures exist and options and peculiarities in whatever language/system you're working on.</p>\n<h3>General terms:</h3>\n<p>Distributed programming:</p>\n<ul>\n<li>Often uses functional programming: - Higher order functions like map and reduce that take functions and execute them at scale distributed in some fashion and combine the results\nQuantum computing:</li>\n<li>Scott Eranson What Quantum Computing Isn't</li>\n<li>It's exciting, it isn't Star Trek, but it is cool\nMoore's Law:</li>\n<li>Roughly translated: Everything's getting faster exponentially or something</li>\n<li>Really about the chip-making process - things get smaller so you can put more transistors in an area and that means chips often get faster</li>\n<li>Been going on for decades</li>\n<li>Slowing down due to physics - might have to switch to something other than silicon</li>\n<li>Counter to intuition, Moore's Law doesn't mean we don't care about Big O or efficiency, it makes it more important:</li>\n<li>Moore's Law takes us even farther to the right which makes gap between quaddratic and log linear bigger</li>\n<li>With faster computers, we want to solve bigger problems</li>\n<li>Doesn't give us things for free, makes things we do with algorithms more important</li>\n</ul>\n<h3>Moral of the story:</h3>\n<ul>\n<li>You want to optimize your time first and you want to figure out what works and then refine from there</li>\n<li>Programmer time usually matters more than computer time</li>\n<li>Trying to optimize too much up front might actually mean you don't get anything out the door, ship your product, get money, whatever</li>\n<li>Don't want to prematurely optimize</li>\n<li>Want to avoid exponential</li>\n<li>Start with something that works</li>\n<li>Iterate from there</li>\n<li>Figure out the tradeoff appropriate for your use case</li>\n</ul>\n<p>If your code is running on a constrained platform, you might actually even care about constants, fixed size, how much memory it takes</p>\n<p>Start with something that works and get more specific as you go</p>\n<p>In general with efficiency classes, you'll get a feel for them as you go:</p>\n<ul>\n<li>Quaddratic is tractable, just not cheap to scale</li>\n<li>Log linear and linear are cheap</li>\n<li>Logarithmic is almost free</li>\n<li>Constant is free</li>\n</ul>",
      "frontmatter": {
        "date": "2018-07-17",
        "title": "Lambda School: Overview of Algorithmic Techniques",
        "chapter": null,
        "subtitle": null,
        "tags": ["algorithms"],
        "path": "/Overview-of-Algorithmic-Techniques"
      }
    }
  },
  "pageContext": {
    "isCreatedByStatefulCreatePages": false,
    "pathSlug": "/Overview-of-Algorithmic-Techniques",
    "prev": {
      "frontmatter": {
        "path": "/CS10-Data-Structures-And-Algorithms-Day-One",
        "title": "CS10: Data Structures & Algorithms",
        "tags": ["data structures", "algorithms", "CS10"],
        "subtitle": "Day One",
        "chapter": null
      }
    },
    "next": {
      "frontmatter": {
        "path": "/CS5-Graphs-I",
        "title": "CS5: Graphs I",
        "tags": ["CS5", "graphs"],
        "subtitle": null,
        "chapter": null
      }
    }
  }
}
