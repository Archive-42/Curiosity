{
  "data": {
    "markdownRemark": {
      "html": "<h3>Applications of Sorting:</h3>\n<ul>\n<li><em>Searching</em>: Binary search tests whether an item is in a dictionary in O(log n) time given keys are sorted.</li>\n<li><em>Closest pair</em>: Once numbers are sorted, closest pair of numbers have to be next to each other in sorted order, so a linear search completes job.</li>\n<li><em>Element uniqueness</em>: Similar to closest-pair, checking to see in linear time (after sorting) if two values are the same.</li>\n<li><em>Frequency distribution</em>: If items are sorted, can sweep from left to right to count them. To find how many times <em>k</em> occurs, look up <em>k</em> using binary search in a sorted array of keys - can find the count in O(log n + c) time where <em>c</em> is the number of occurrence of <em>k</em></li>\n<li><em>Selection</em>: what is the <em>kth</em> largest item in the array could be found in constant time if sorted by looking at the <em>kth</em> position</li>\n</ul>\n<p><strong>Take Home</strong>: Sorting lies at the heart of many algorithms. Sorting the data is one of the first things cany algorithm designer should try in the quest of efficiency.</p>\n<h3>Stop and Think: Finding the Intersection:</h3>\n<p><em>Problem</em>: Given an efficient algorithm to determine whether two sets (of size m and n respectfully) are disjoint, analyze the worst-case complexity in terms of m and n considering the case where m is substantially smaller than n.</p>\n<p><em>Solution</em>:</p>\n<ul>\n<li>\n<p><em>Sort the big set</em> - this can be done in O(n log n) time. Then do binary search with each m element in the small set to see if it exists in the big one -> O((n+m) log n)</p>\n</li>\n<li>\n<p><em>Sort the small set</em> - this can be done in O(m log m) time. Then do binary search with each n element in big set to see if it 4exists in the smnall set -> O((n + m) log m)</p>\n</li>\n<li>\n<p><em>Sort both sets</em> - when both are sorted, no need for binary search, can just compare smallest elements, discard smaller one if not identical, and repeat - O(n log n + m log m + n + m)</p>\n</li>\n<li>\n<p>Sorting the smallest set is the best option of these. Note: Expected linear time can be achieved by hashing and verifying that collisions in the same bucket are identical elements.</p>\n</li>\n</ul>\n<h3>Pragmatics of Sorting</h3>\n<ul>\n<li>Increasing or decreasing order?</li>\n<li>Sorting just the key or the entire record - need to specify which field is the key in any complex record and understand the full extent of each record.</li>\n<li>What to do with equal keys? Sometimes relative order matters - may need a secondary key to resolve ties. Sometimes it is required to leave items in the same relative order as in the original permutation. Sorting algorithms that automatically enforce that requirement are called <em>stable</em>.</li>\n<li>What about non-numerical data? Alphabetizing is the sorting of text strings - libraries have very complete and complicated rules concerning the relative collating sequence of characters and punctuation.</li>\n</ul>\n<p>The way to specify such matters to your sorting algorithm is with an application-specific pairwise-element comparison function. By abstracting the pairwise ordering decision to such a comparison function, we can implement sorting independently of such criteria.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">qsort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>base<span class=\"token punctuation\">,</span> size_t nel<span class=\"token punctuation\">,</span> size_t width<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span> compare<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Qsort sorts the first nel elements of an array (pointed to by base) where each element is width-bytes long. The order is determined by the compare function which takes pointers to two width-byte elements and returns a negative number if the first belongs before the second, a positive number if the second belongs before the first, and zero if they are the same.</p>\n<p>Comparison function to sort integers in increasing order:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">intcompare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>i <span class=\"token operator\">></span> <span class=\"token operator\">*</span>j<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>i <span class=\"token operator\">&lt;</span> <span class=\"token operator\">*</span>j<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This comparison function can be used to sort an array <em>a</em> of which the first <em>n</em> elements are occupied as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">qsort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> intcompare<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Selection sort is a simple-to-code algorithm that repeatedly extracts the smallest remaining element from the unsorted part of the list.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">SelectionSort</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span>\n    For i <span class=\"token operator\">=</span> <span class=\"token number\">1</span> to n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">do</span>\n        Sort<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Find<span class=\"token operator\">-</span>Minimum from A\n        Delete<span class=\"token operator\">-</span>Minimum from A\n    <span class=\"token function\">Return</span><span class=\"token punctuation\">(</span>Sort<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In Chapter 2, we implemented selection sort on an array. We partitioned the input array into sorted and unsorted regions. To find the smallest item, we did a linear sweep through the unsorted portion of the array. Smallest item was swapped with the <em>ith</em> item in the array before moving to the next iteration. Selection sort performs <em>n</em> iterations where average iteration takes n/2 steps for O(n<sup>2</sup>) time.</p>\n<p>It takes O(1) time to remove an item from an unsorted array once located, but O(n) time to find smallest. If we replace the data structure with a priority queue(heap or balanced tree), operations take O(log n) time instead of O(n), which speeds selection sort up from O(n<sup>2</sup> to O(n log n).</p>\n<p>The name typically given to this algorithm, <em>heapsort</em>, obscures the relationship between them, but heapsort is nothing but an implementation of selection sort using the right data structure.</p>\n<h3>Heaps</h3>\n<p>Heaps are a simple and elegant data structure for efficiently supporting the priority queue operations insert and extract-min.</p>\n<p>A heap-labeled tree is defined to be a binary tree such that the key labeling of each node dominates the key labeling of each of its children. In a min-heap, the parent dominates its children by having a smaller key than they do, while in a max-heap, the parent nodes dominate by being larger.</p>\n<p>You do not need pointers for heaps because you can store data as an array of keys and use the position of keys to implicitly satisfy the role of pointers - root at first element, then left child followed by right child.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    item_type q<span class=\"token punctuation\">[</span>PQ_SIZE <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* body of queue */</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of queue elements */</span>\n<span class=\"token punctuation\">}</span> priority queue<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">pq_parent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>n <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* implicitly take floor (n/2) */</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">pq_child</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h3>Stop and Think: Who's Where in the Heap?</h3>\n<p><em>Problem</em>: How can we efficiently search for a particular key in a heap?\n<em>Solution</em>: We can't. Binary search does not work because a heap is not a binary search tree. We know next to nothing about relative order of the n/2 leaf elements in a heap - nothing that helps us avoid doing a linear search.</p>\n<h4>Insertion</h4>\n<p>Insert new element at leftmost open spot in the array. If that element dominates its parent, it is swapped with its parent recursively until order is established.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">pq_insert</span><span class=\"token punctuation\">(</span>priority_queue <span class=\"token operator\">*</span>q<span class=\"token punctuation\">,</span> item_type x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q<span class=\"token operator\">-></span>n <span class=\"token operator\">>=</span> PQ_SIZE<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Warning: priority queue overflow, insert x=%d/n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        q<span class=\"token operator\">-></span>n <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>q<span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span>q<span class=\"token operator\">-></span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">bubble_up</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> q<span class=\"token operator\">-></span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">bubble_up</span><span class=\"token punctuation\">(</span>priority_queue <span class=\"token operator\">*</span>q<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">pq_parent</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* at root of heap, no parent */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span><span class=\"token function\">pq_parent</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">pq_swap</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> <span class=\"token function\">pq_parent</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">bubble_up</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> pq<span class=\"token punctuation\">,</span> <span class=\"token function\">pq_parent</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Swap process takes constant time at each level. Since the height of an <em>n</em>-element heap is ⌊lg n⌋, each insertion takes at most O(log n) time, so a heap of <em>n</em> elements can be constructed in O(n log n) time through n insertions.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">pq_init</span><span class=\"token punctuation\">(</span>priority_queue <span class=\"token operator\">*</span>q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    q<span class=\"token operator\">-></span>n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">make_heap</span><span class=\"token punctuation\">(</span>priority_queue <span class=\"token operator\">*</span>q<span class=\"token punctuation\">,</span> item_type s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token function\">pq_init</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">pq_insert</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4>Extracting the Minimum</h4>\n<p>The top of the heap sits at the first position of the array, but removing it leaves a hole. This can be filled by replacing it with the element at the <em>nth</em> position, but heap order may not be correct. If the root is dominated by its children, it is then swapped with the most dominant child and swapping keeps occurring down the heap until no parent is dominated by its children. This is referred to as bubbling down and also heapify (since it merges two heaps - the subtrees below the original root) with a new key.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">item_type <span class=\"token function\">extract_min</span><span class=\"token punctuation\">(</span>priority_queue <span class=\"token operator\">*</span>q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> min <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* minimum value */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q<span class=\"token operator\">-></span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Warning: Empty queue.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        min <span class=\"token operator\">=</span> q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span>q<span class=\"token operator\">-></span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        q<span class=\"token operator\">-></span>n <span class=\"token operator\">=</span> q<span class=\"token operator\">-></span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">bubble_down</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> min<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We reach a leaf after ⌊lg n⌋ bubble_down steps, each in constant time. Root deletion is thus a O(log n) operation.</p>\n<p>Exchanging the maximum element with the last element and calling heapify repeatedly gives O(n log n) sorting algorithm called heapsort.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">bubble_down</span><span class=\"token punctuation\">(</span>priority_queue <span class=\"token operator\">*</span>q<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* child index */</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token keyword\">int</span> min_index<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* index of lightest child */</span>\n    c <span class=\"token operator\">=</span> <span class=\"token function\">pq_young_child</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    min_index <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> q<span class=\"token operator\">-></span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span>min_index<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span>c<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> min_index <span class=\"token operator\">=</span> c<span class=\"token operator\">+</span>i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>min_index <span class=\"token operator\">!=</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">pq_swap</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> min_index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">bubble_down</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> min_index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">heapsort</span><span class=\"token punctuation\">(</span>item_type s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    priority_queue q<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* heap for heapsort */</span>\n    <span class=\"token function\">make_heap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">extract_min</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We can create a heap by performing n/2 calls to bubble_down...</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">make_heap</span><span class=\"token punctuation\">(</span>priority_queue <span class=\"token operator\">*</span>q<span class=\"token punctuation\">,</span> item_type s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    q<span class=\"token operator\">-></span>n <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> q<span class=\"token operator\">-></span>n<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token function\">bubble_down</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">/* Works in linear time */</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Stop and Think: Where in the Heap?</h3>\n<p><em>Problem</em>: Given an array-based heap on <em>n</em> elements and a real number <em>x</em>, efficiently determine whether the <em>kth</em> smallest element is greater than or equal to <em>x</em>. Algorithm should be O(k) in the worst-case, independent of the size of the heap. Hint: You do not have to find the <em>kth</em> smallest element, only determine its relationship to <em>x</em>.</p>\n<p><em>Solution</em>:</p>\n<p>Two ideas that lead to correct but inefficient algorithms:</p>\n<ol>\n<li>\n<p>Call extract-min <em>k</em> times and test whether all of these sare less than <em>x</em>. This explicitly sorts the first <em>k</em> elements, so gives more information than the desired answer but takes O(k log n) time.</p>\n</li>\n<li>\n<p>The <em>kth</em> smallest element cannot be deeper than the <em>kth</em> level of the heap since the path from it to the root must go through elements of decreasing value. Thus we can look at all the elements in the first <em>k</em> levels of the heap and count how many of them are less than <em>x</em>, stopping when we find either <em>k</em> of them or run out of elements. This is correct but takes O(min(n, 2<sup>k</sup>)) time since the top <em>k</em> elements have 2<sup>k</sup> elements.</p>\n</li>\n</ol>\n<p>An O(k) solution can look at only <em>k</em> elements smaller than <em>x</em>, plus at most O(k) elements greater than <em>x</em>. Consider the following recursive function, called at the root with <em>i = 1</em> and <em>count = k</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">heap_compare</span><span class=\"token punctuation\">(</span>priority_queue <span class=\"token operator\">*</span>q<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> q<span class=\"token operator\">-></span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q<span class=\"token operator\">-></span>q<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        count <span class=\"token operator\">=</span> <span class=\"token function\">heap_compare</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token function\">pq_young_child</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> count<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        count <span class=\"token operator\">=</span> <span class=\"token function\">heap_compare</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token function\">pq_young_child</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>If the root of the min-heap is greater than or equal to <em>x</em>, no elements in the heap can be. This searches the children of all nodes smaller than <em>x</em> until it finds <em>k</em> of them and returns 0 or they are exhausted, where it returns a value greater than 0. The only nodes whose children we look at are those less than <em>x</em> and up to <em>k</em> of them. Each node has at most 2 children, so at most <em>3k</em> nodes making this O(k).</p>\n<h3>Sort by Incremental Insertion</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">InsertionSort</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span>\n    A<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>∞\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span> to n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">do</span>\n        j <span class=\"token operator\">=</span> i\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> A<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">do</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> A<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                j <span class=\"token operator\">=</span> j <span class=\"token operator\">-</span> <span class=\"token number\">1</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Although it takes O(n<sup>2</sup>) in worst cast, performs considerably better on data that is almost sorted. Incremental insertion is particularly useful in geometric algorithms.</p>\n<h3>Merge Sort</h3>\n<p>A recursive approach to sorting involves partitioning elements into two groups, sorting recursively, and then interleaving the sorted lists. Base case is when the subarray consists of one element. Because the recursion goes log n deep and a linear amount of work is done per level, merge sort is O(n log n) worst-case.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">Mergesort <span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Merge</span><span class=\"token punctuation\">(</span> <span class=\"token function\">MergeSort</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> ⌊n<span class=\"token operator\">/</span><span class=\"token number\">2</span>⌋<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">Mergesort</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>⌊n<span class=\"token operator\">/</span><span class=\"token number\">2</span>⌋ <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// Pseudocode</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">mergesort</span><span class=\"token punctuation\">(</span>item_type s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> low<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> middle<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* index of middle element */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">&lt;</span> high<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        middle <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">+</span> high<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">mergesort</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> middle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">mergesort</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> middle<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> middle<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>item_type s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> low<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> middle<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    queue buffer1<span class=\"token punctuation\">,</span> buffer2<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* buffers to hold elements for merging */</span>\n    <span class=\"token function\">init_queue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">init_queue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> low<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> middle<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer1<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> middle<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> high<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer2<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    i <span class=\"token operator\">=</span> low<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token function\">empty_queue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer1<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">empty_queue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">headq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer1<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token function\">headq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            s<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            s<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">empty_queue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> s<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">empty_queue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> s<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>buffer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Quicksort</h3>\n<p>Pick random item as pivot, separate other items into two piles, one less than and one greater than pivot. Then sort elements to left and right independently - can use recursive sorting algorithm to use partitioning in each sub problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>item_type s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* index of partition */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span> h <span class=\"token operator\">-</span> l<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        p <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> p<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> p<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We can partition the array in one linear scan for a given pivot by maintaining three sections of the array - less than the pivot (to the left of firsthigh), greater than or equal to pivot (between firsthigh and i) and unexplored (to the right of i) as implemented below:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>item_type s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token keyword\">int</span> p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* pivot element index */</span>\n    <span class=\"token keyword\">int</span> firsthigh<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* divider position for pivot element */</span>\n    p <span class=\"token operator\">=</span> h<span class=\"token punctuation\">;</span>\n    firsthigh <span class=\"token operator\">=</span> l<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> l<span class=\"token punctuation\">,</span> i <span class=\"token operator\">&lt;</span> h<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span>firsthigh<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            firsthigh<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span>firsthigh<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> firsthigh<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Worst case for quicksort is O(n<sup>2</sup>). Average case O(n log n)</p>\n<p>Quicksort runs in O(n log n) time with high probability given randomly ordered data - if selecting specific element.\n\"Randomized quicksort runs in O(n log n) time on any input with high probability\"</p>\n<p><em>Randomization</em> is a powerful tool to improve algorithms with bad worst-case but good avergage-case complexity.</p>\n<p>Some approaches to designing efficient randomization algorithms:</p>\n<ul>\n<li>Random sampling: Select random sample of data to study - if random, results should be representative.</li>\n<li>Randomized hashing: Hashing can be used to implement dictionary operations in O(1) expected time, but for any hashing function, there is a worst case set of keys that hash to the same number. If you select a random hash function from a group of good ones - can improve guarantee.</li>\n<li>Randomized search - can be used to drive search techniques such as simulated annealing.</li>\n</ul>\n<h3>Stop &#x26; Think: The Nuts and Bolts</h3>\n<p><em>Problem</em>: You are given a collection of <em>n</em> bolts of different widths and <em>n</em> corresponding nuts. You can test whether a given nut and bolt fit together, from which you learn whether the nut is too large, too small, or an exact match for the bolt. The differences in size between pairs of nuts or bolts is too small to see by eye, so you cannot compare the size of two nuts or two bolts directly. You are to match each bolt to each nut.\nGive an O(n<sup>2</sup>) algorithm to solve the nuts and bolts problem. Then give a randomized O(n log n) expected time algorithm for the same problem.</p>\n<p><em>Solution</em>: Brute force algorithms would mean starting with the first bolt and matching against each nut until a match was found. Worst case, this requires n<sup>2</sup> comparisons altogether - n for each bolt.</p>\n<p>Sorting the nuts and bolts by size would yield matches as the <em>ith</em> sized bolt should match the <em>ith</em> sized nut. We can partition the nuts into sizes less than bolt <em>b</em> and greater than <em>b</em>. Once we find the matching nut to <em>b</em>, we can use it to partition the nuts. In 2n-2 comparisons, we'd partition the nuts and bolts and then can use randomized quicksort.</p>\n<p>It is difficult to say which O(n log n) sorting function is faster - implementation details and system quirks like cache performance and memory size might be decisive factors. Experiments show that when a quicksort is implemented well, it is typically 3-4 times faster than mergesort or heapsort, because the operations in the innermost loop are simpler.</p>\n<h3>Bucketing</h3>\n<p>Bucketing is very effective whenever you are confident that the distribution of data is fairly uniform. The idea underlies hash tables, kd-trees, etc.</p>\n<h3>Take Home:</h3>\n<p>Sorting can be used to illustrate most algorithm design paradigms. Data structure techniques, divide-and-conquer, randomization and incremental construction all lead to efficient sorting algorithms.</p>\n<h3>Binary Search</h3>\n<p>Binary search is a fast algorithm for searching in a sorted array of keys <em>S</em>. To search for key <em>q</em>, we compare <em>q</em> to middle key <em>S[n/2]</em>. It <em>q</em> appears before <em>S[n/2]</em> it must reside in the top half of <em>S</em>. If not, it must reside in the bottom half of <em>S</em>. By repeating this process recursively on the correct half, we can locate the key in ⌈lg n⌉ comparisons.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">binary_search</span><span class=\"token punctuation\">(</span>item_type s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> item_type key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> low<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> middle<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* index of middle element */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">></span> high<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token comment\">/* key not found */</span>\n    middle <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">+</span> high<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>middle<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> key<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> middle<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>middle<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> key<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">binary_search</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> middle<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">binary_search</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> middle<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Take Home:</h3>\n<p>Binary search and its variants are the quintessential divide and conquer algorithms.</p>\n<h3>Divide and Conqueur:</h3>\n<p>One of the most powerful techniques for solving problems is to break them down into smaller, more easily solved pieces. A recursive algorithms is more apparent when broken into smaller instances of the same type. Effective parallel processing requires decomposing jobs into at least as many tasks as processors. Divide and conquer involves splitting a problem into parts (say halves), solving those parts, and then stitching the parts together to form a full solution.</p>",
      "frontmatter": {
        "date": "2019-01-15",
        "title": "Algorithm Design Manual:",
        "chapter": "Chapter Four",
        "subtitle": "Sorting and Searching",
        "tags": [
          "algorithms",
          "sorting",
          "searching",
          "Algorithm Design Manual"
        ],
        "path": "/Algorithm-Design-Manual--Chapter-Four"
      }
    }
  },
  "pageContext": {
    "isCreatedByStatefulCreatePages": false,
    "pathSlug": "/Algorithm-Design-Manual--Chapter-Four",
    "prev": {
      "frontmatter": {
        "path": "/Algorithm-Design-Manual--Chapter-Three",
        "title": "Algorithm Design Manual:",
        "tags": ["algorithms", "data structures", "Algorithm Design Manual"],
        "subtitle": "Data Structures",
        "chapter": "Chapter Three"
      }
    },
    "next": {
      "frontmatter": {
        "path": "/Algorithm-Design-Manual--Chapter-Five",
        "title": "Algorithm Design Manual:",
        "tags": ["algorithms", "graphs", "Algorithm Design Manual"],
        "subtitle": "Graph Traversal",
        "chapter": "Chapter Five"
      }
    }
  }
}
