//a side-by-side reference sheet//

[#grammar-invocation grammar and invocation] | [#var-expr variables and expressions] | [#arithmetic-logic arithmetic and logic] | [#strings strings] | [#arrays arrays] | [#sets sets] | [#arith-seq arithmetic sequences] | [#dictionaries dictionaries] | [#functions functions] | [#execution-control execution control] | [#exceptions exceptions] | [#streams streams] | [#processes-env process and environment] | [#libraries-namespaces libraries and namespaces] |  [#reflection reflection]
 
[#vectors vectors] | [#matrices matrices] |  [#combinatorics combinatorics] | [#number-theory number theory] | [#elliptic-curves elliptic curves] | [#rational-algebraic-numbers rational and algebraic numbers] | [#polynomials polynomials] | [#special-functions special functions] | [#permutations permutations] | [#groups groups] | [#subgroups subgroups] | [#group-homomorphisms group homomorphisms] | [#actions actions]

||~ ||~ [#pari-gp pari/gp]||~ [#magma magma]||~ [#gap gap]||~ [#singular singular]||
||[[# version-used]][#version-used-note version used] _
@<&nbsp;>@||##gray|//2.7//##||##gray|//2.21//##||##gray|//4.7//##||##gray|//4.0//##||
||[[# show-version]][#show-version-note show version] _
@<&nbsp;>@||$ gp @@--@@version|| ||$ gap -h||$ singular -vb||
||||||||||~ [[# grammar-invocation]][#grammar-invocation-note grammar and invocation]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# interpreter]][#interpreter-note interpreter] _
@<&nbsp;>@||$ cat hello.gp _
print("Hello, World!") _
quit _
 _
$ gp -q hello.gp _
Hello, World!|| || ||$ singular -b ##gray|//foo//##.sing||
||[[# repl]][#repl-note repl] _
@<&nbsp;>@||$ gp||[http://magma.maths.usyd.edu.au/calc/ online calculator]||$ gap||$ singular||
||[[# block-delimiters]][#block-delimiters-note block delimiters] _
@<&nbsp;>@||{ ##gray|//...//## } _
 _
##gray|//braces cannot be nested//##|| ||function( ) ##gray|//...//## end _
if then ##gray|//...//## elif then ##gray|//...//##  else ##gray|//...//## fi _
while do ##gray|//...//## od _
for do ##gray|//...//## od||{ ##gray|//...//## }||
||[[# stmt-separator]][#stmt-separator-note statement separator]||##gray|//newline or//## ; _
 _
##gray|//Newlines don't separate statements inside braces.//## _
 _
##gray|//A semicolon suppresses echoing value of previous expression.//##||; _
 _
##gray|//A line can be broken anywhere, even inside a numeric literal or string, if the newline is preceded by a backslash:// \##||; _
 _
##gray|//Two trailing semicolons// ;;  //suppress echoing value of previous expression.//##||;||
||[[# eol-comment]][#eol-comment-note end-of-line comment] _
@<&nbsp;>@||1 + 1 ##gray|\\ addition##||1 + 1; ##gray|@@//@@ addition##||1 + 1; ##gray|# addition##||// ##gray|//comment//##||
||[[# multiple-line-comment]][#multiple-line-comment-note multiple line comment] _
@<&nbsp;>@||1 + ##gray|/* addition */## 1||1 + ##gray|/* addition */## 1;||##gray|//none//##||/* ##gray|//comment line _
another comment//## */||
||||||||||~ [[# var-expr]][#var-expr-note variables and expressions]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# assignment]][#assignment-note assignment]||x = 3.14||a := 3;||a := 3;||int a; _
a = 3; _
 _
##gray|@@//@@ It is an error to assign to undeclared variable.##||
||[[# parallel-assignment]][#parallel-assignment-note parallel assignment]||[a, b] = [3, 4]|| ||##gray|//none//##||int a, b; _
a, b = 3, 4;||
||[[# compound-assignment]][#compound-assignment-note compound assignment]||+= -= *= /= \= \/= %= _
 _
##gray|@@\\@@ bit operations:## _
@@<<= >>=@@|| ||##gray|//none//##||##gray|//none//##||
||[[# incr-decr]][#incr-decr-note increment and decrement]||##gray|//postmodifiers://## _
x++ x@@--@@|| ||##gray|//none//##||@@x++ x--@@||
||[[# non-referential-id]][#non-referential-id-note non-referential identifier]||##gray|//any unassigned identifier is non-referential//##||##gray|//none//##||##gray|//none//##||##gray|//none//##||
||[[# id-as-val]][#id-as-val-note identifier as value]||x = 3 _
y = 'x|| || || ||
||[[# global-var]][#global-var-note global variable]||##gray|//variables are global by default//##|| || || ||
||[[# local-var]][#local-var-note local variable]||tmp = 19 _
 _
add(x, y, z) = { _
@<&nbsp;&nbsp;>@##gray|@@\\@@ don't overwrite global tmp:## _
@<&nbsp;&nbsp;>@my(tmp = x + y); _
@<&nbsp;&nbsp;>@tmp + z _
} _
 _
##gray|@@\\@@ local keyword declares dynamic scope##|| || || ||
||[[# null]][#null-note null] _
@<&nbsp;>@||##gray|//none//##|| || || ||
||[[# null-test]][#null-test-note null test] _
@<&nbsp;>@||##gray|//none//##|| || || ||
||[[# undef-var]][#undef-var-note undefined variable access] _
@<&nbsp;>@||##gray|//treated as an unknown number//##|| ||##gray|//error//##|| ||
||[[# rm-var-binding]][#rm-var-binding-note remove variable binding]||kill(x)||delete x;|| || ||
||[[# cond-expr]][#cond-expr-note conditional expression] _
@<&nbsp;>@||if(x > 0, x, -x)||if x lt 0 then -x; else x; end if;|| || ||
||||||||||~ [[# arithmetic-logic]][#arithmetic-logic-note arithmetic and logic]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# true-false]][#true-false-note true and false] _
@<&nbsp;>@||1 0||true false||true false||1 0||
||[[# falsehoods]][#falsehoods-note falsehoods] _
@<&nbsp;>@||0 _
0.0 _
Mod(0, 5) _
Pol([0]) _
[0, 0, 0] _
[0, 0; 0, 0] _
[[0, 0], 0]||false||false||0||
||[[# logical-op]][#logical-op-note logical operators]||@@&& || !@@||not true or (true and false);||not true or (true and false)||! 1 @@||@@ (1 && 0)||
||[[# relational-op]][#relational-op-note relational operators]||== != > < >= <=||eq ne lt gt le ge _
 _
##gray|eq //raises an error when the operands are of different type.//## _
 _
##gray|cmpeq //does not.//##||@@=@@ <> < > <= >=||== != < > <= >= _
 _
<> ##gray|//is a synonym for//## !=||
||[[# arith-op]][#arith-op-note arithmetic operators]||+ - * / %||+ - * / mod||+ - * / mod _
 _
##gray|//the operators// + - * / //are overloaded for integers, rationals, and floats; other arithmetic functions aren't and there are no implicit conversions; use constructors to convert://## _
Rat(3.1) _
Float(3) _
Float(31/10)||##gray|//Operators are for integers only unless _
base ring with coefficient field is declared.//## _
@@+ - * / %@@ _
 _
##gray|mod //is synonym for// %##||
||[[# int-div]][#int-div-note integer division] _
@<&nbsp;>@||a \ b _
divrem(a, b)[1] _
 _
##gray|@@\\@@ rounded integer division:## _
a \/ b||a := 7; _
b := 3; _
 _
div(a, b);||QuoInt(a, b);||int a, b = 7, 3; _
a div b; _
 _
##gray|@@//@@ a / b also performs integer division when _
@@//@@ no base ring is declared.##||
||[[# int-div-zero]][#int-div-zero-note integer division by zero]||##gray|//error//##||##gray|//User error//##||##gray|//error//##||##gray|//error//##||
||[[# float-div]][#float-div-note float division]||7 / 3|| ||##gray|//depending upon the types of a and b, the value can be an exact rational, a machine float, or an arbitrary precision float://## _
a / b||ring r = real,(x,y,z),(dp); _
 _
3.1 / 7.2;||
||[[# float-div-zero]][#float-div-zero-note float division by zero]||##gray|//error//##||##gray|//Runtime error//##||##gray|//error//##||##gray|//error//##||
||[[# power]][#power-note power]||2 ^ 32||2 ^ 32;||2 ^ 32||2 ^ 16 _
2 ** 16||
||[[# sqrt]][#sqrt-note sqrt] _
@<&nbsp;>@||sqrt(2)||Sqrt(2);||2.0 ^ 0.5||##gray|//none//##||
||[[# sqrt-negative-one]][#sqrt-negative-one-note sqrt -1] _
@<&nbsp;>@||1.000 * I|| ||##gray|-1.0 ^ 0.5 //evaluates to// -1.##||##gray|//none//##||
||[[# transcendental-func]][#transcendental-func-note transcendental functions]||exp log ##gray|//none//## _
sin cos tan _
asin acos atan _
##gray|//none//##||Exp Log _
Sin Cos Tan _
Arcsin Arccos Arctan _
Arctan2||##gray|//arguments must be floats; no implicit conversion of integers to floats://## _
Exp Log _
Sin Cos Tan _
Asin Acos Atan _
Atan2(##gray|//y//##, ##gray|//x//##)||##gray|//none//##||
||[[# transcendental-const]][#transcendental-const-note transcendental constants] _
##gray|//π and Euler's number//##||Pi exp(1)|| ||FLOAT.PI FLOAT.E||LIB "general.lib"; _
 _
##gray|@@//@@ print specified number of digits:## _
number_pi(100); _
number_e(100);||
||[[# float-truncation]][#float-truncation-note float truncation] _
##gray|//round towards zero, round to nearest integer, round down, round up//##||truncate(x) _
round(x) _
floor(x) _
ceil(x)|| ||Trunc Round Floor Ceil|| ||
||[[# absolute-val]][#absolute-val-note absolute value] _
##gray|//and signum//##||abs(x) _
sign(x)|| ||AbsInt _
##gray|//no absolute value for floats?//## _
SignInt _
SignFloat||LIB "general.lib"; _
 _
absValue(-7); _
 _
ring r = real,(x,y,z),(dp); _
absValue(-7.1);||
||[[# int-overflow]][#int-overflow-note integer overflow] _
@<&nbsp;>@||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||##gray|//modular arithmetic with warning//##||
||[[# float-overflow]][#float-overflow-note float overflow] _
@<&nbsp;>@||##gray|//error//##|| ||##gray|# prints as inf:## _
FLOAT.INFINTY|| ||
||[[# rational-construction]][#rational-construction-note rational construction]||2 / 7||2 / 7;||2 / 7|| ||
||[[# rational-decomposition]][#rational-decomposition-note rational decomposition] _
@<&nbsp;>@||x = 2 / 7 _
numerator(x) _
denominator(x)||Numerator(2 / 7); _
Denominator(2 / 7 );||x := 2 / 7; _
NumeratorRat(x); _
DenominatorRat(x);|| ||
||[[# decimal-approx]][#decimal-approx-note decimal approximation]||2 / 7 + 0. _
 _
##gray|@@\\@@ change precision to 100:## _
\p 100 _
2 / 7 + 0.|| || || ||
||[[# complex-construction]][#complex-construction-note complex construction] _
@<&nbsp;>@||1 + 3 * I|| ||##gray|//none//##|| ||
||[[# complex-decomposition]][#complex-decomposition-note complex decomposition] _
##gray|//real and imaginary part, argument and modulus, conjugate//##||real(z) imag(z) _
arg(z) abs(z) _
conj(z)|| ||##gray|//none//##|| ||
||[[# random-num]][#random-num-note random number] _
##gray|//uniform integer, uniform float//##||random(100) _
random(1.0)||Random(0, 99); _
##gray|//??//##||rs := RandomSource(IsMersenneTwister); _
Random(rs, 0, 99); _
##gray|//??//##|| ||
||[[# random-seed]][#random-seed-note random seed] _
##gray|//set, get//##||setrand(17) _
getrand()||SetSeed(42); _
seed := GetSeed(();||rs := RandomSource(IsMersenneTwister, 17); _
State(rs);|| ||
||[[# bit-op]][#bit-op-note bit operators]||##gray|@@\\@@ left shift:## _
5 @@<<@@ 1 _
##gray|@@\\@@ right shift:## _
5 @@>>@@ 1|| ||##gray|//none//##|| ||
||[[# binary-octal-hex-literals]][#binary-octal-hex-literals-note binary, octal, and hex literals]|| || ||##gray|//none//##|| ||
||[[# radix]][#radix-note radix]||##gray|@@\\@@ 42 as powers of 7 up to 9th power:## _
42 + O(7^10)||IntegerToString(42, 7);||##gray|//none//##|| ||
||[[# to-array-of-digits]][#to-array-of-digits-note to array of digits]||##gray|@@\\@@ base 10:## _
digits(1234) _
##gray|@@\\@@ base 2:## _
digits(1234, 2) _
##gray|@@\\@@ number of digits in base 10:## _
sizedigits(1234)|| ||ListOfDigits(1234); _
 _
##gray|# other bases?##|| ||
||||||||||~ [[# strings]][#strings-note strings]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# str-literal]][#str-literal-note string literal] _
@<&nbsp;>@||"don't say \"no\""||"don't say \"no\""||"don't say \"no\""||string s = "don't say \"no\"";||
||[[# newline-in-str-literal]][#newline-in-str-literal-note newline in literal] _
@<&nbsp;>@||##gray|//no; use \n escape//##||##gray|//A line break in a string literal results in a newline in the string unless preceded by a backslash.//##||##gray|//no//##||##gray|//Yes; runaway strings are possible; there is a predefined string variable newline which contains a single newline character.//##||
||[[# str-literal-esc]][#str-literal-esc-note literal escapes]||\n \t \" \\||\" \\ \n \r \t||\b \c \n \r \" \' \\ \##gray|//ooo//## _
 _
##gray|//when writing to a buffered output stream, encountering a// \c //causes a flush of output.//##||\" \\||
||[[# str-concat]][#str-concat-note concatenate] _
@<&nbsp;>@||Str("one ", "two ", "three") _
concat("one ", "two ", "three")||"one " cat "two " cat "three"; _
"one " * "two " * "three"; _
&cat ["one ", "two ", "three "]; _
&* ["one ", "two ", "three "];||Concatenation("one ", "two ", "three");||string s = "one" + "two" + "three";||
||[[# str-replicate]][#str-replicate-note replicate]|| ||hbar := "-" ^ 80;|| || ||
||[[# translate-case]][#translate-case-note translate case]|| || ||UppercaseString("foo"); _
LowercaseString("FOO");|| ||
||[[# trim]][#trim-note trim] _
@<&nbsp;>@|| || ||##gray|//none//##|| ||
||[[# num-to-str]][#num-to-str-note number to string] _
@<&nbsp;>@||Str(8) _
 _
##gray|@@\\@@ implicit conversion to string:## _
concat("value: ", 8)||"value: " * IntegerToString(8);||Concatenation("value: ", String(8));||"value: " + string(8)||
||[[# str-to-num]][#str-to-num-note string to number]||7 + eval("12") _
73.9 + eval(".037")|| ||7 + Int("12"); _
73.9 + Float(".037");|| ||
||[[# str-join]][#str-join-note string join]|| || ||a := ["foo", "bar", "baz"]; _
JoinStringsWithSeparator(a, ","); || ||
||[[# split]][#split-note split] _
@<&nbsp;>@|| ||Split("foo,bar,baz", ",");||SplitString("foo,bar,baz", ",");|| ||
||[[# str-subst]][#str-subst-note substitute]|| || ||##gray|# replace all occurrences:## _
ReplacedString("do re mi mi", "mi", "ma");|| ||
||[[# str-len]][#str-len-note length] _
@<&nbsp;>@||length("hello") _
#"hello"||# "hello";||Length("hello");||size("hello");||
||[[# index-substr]][#index-substr-note index of substring]|| ||Index("hello", "el"); _
Position("hello", "el"); _
##gray|/* both return 0 if substring not found */##|| ||##gray|// evaluates to 2:## _
find("hello", "el");||
||[[# extract-substr]][#extract-substr-note extract substring]|| ||Substring("hello", 2, 2);||s := "hello"; _
s{[2..3]};||##gray|// start index and substring length:## _
"hello"[2, 2]||
||[[# char-literal]][#char-literal-note character literal] _
@<&nbsp;>@|| || ||'h'|| ||
||[[# lookup-char]][#lookup-char-note character lookup]|| || ||s := "hello"; _
##gray|# the character 'h':## _
s[1]; _
 _
##gray|# cannot use index notation on string literal##||##gray|// the character h:## _
"hello"[1]||
||[[# chr-ord]][#chr-ord-note chr and ord]||Strchr([65]) _
Vecsmall("A")|| ||CharInt(65) _
IntChar('A')|| ||
||[[# delete-char]][#delete-char-note delete characters]|| || ||s := "disemvowel me"; _
##gray|# no retval; modifies s in place:## _
RemoveCharacters(s, "aeiou"); || ||
||||||||||~ [[# arrays]][#arrays-note arrays]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# array-literal]][#array-literal-note literal]||##gray|\\ [1, 2, 3] is a vector literal:## _
List([1, 2, 3])||a := [1, 2, 3];||[1, 2, 3]; _
 _
##gray|# creates array with gap at fourth index; _
# reading a[4] causes an error:## _
a := [1, 2, 3, , 5];||list a= 1, 2, 3; _
list a = list(1, 2, 3); _
 _
##gray|@@//@@ Singular lists are fixed length.##||
||[[# array-size]][#array-size-note size] _
@<&nbsp;>@||length(List([1, 2, 3])) _
#List([1, 2, 3])||# [1, 2, 3];||Length([1, 2, 3]);||size(a);||
||[[# array-lookup]][#array-lookup-note lookup]||##gray|\\ access time is O(1).## _
##gray|\\ indices start at one:## _
List([1, 2, 3])[1]||##gray|@@//@@ indices start at one:## _
[6, 7, 8][1];||##gray|# indices start at one:## _
a := [1, 2, 3]; _
a[1];||##gray|@@//@@ indices start at one:## _
a[1];||
||[[# array-update]][#array-update-note update] _
@<&nbsp;>@||listput(a, 7, 1)||a[1] := 7;||a[1] := 7;||a[1] = 7;||
||[[# array-out-of-bounds]][#array-out-of-bounds-note out-of-bounds behavior]||##gray|//out of allowed range error//##||##gray|//Runtime error on lookup.//## _
 _
##gray|//For update, size of array is increased if necessary; runtime error to look up unassigned slot in between assigned slots.//##||##gray|//Lookups result in errors; arrays can have gaps which also cause lookup errors. _
 _
An update will expand the array, possibly creating gaps.//##||##gray|//error//##||
||[[# array-element-index]][#array-element-index-note element index]||##gray|//none//##|| ||##gray|# returns 3:## _
Position([7, 8, 9, 9], 9); _
 _
##gray|# returns [3, 4]:## _
Positions([7, 8, 9, 9], 9);|| ||
||[[# array-slice]][#array-slice-note slice] _
@<&nbsp;>@||##gray|//none//##|| || || ||
||[[# array-of-integers-as-index]][#array-of-integers-as-index-note array of integers as index]||##gray|//none//##|| || || ||
||[[# array-back]][#array-back-note manipulate back]||a = List([6, 7, 8]) _
listput(a, 9) _
elem = listpop(a)||a := [6, 7, 8]; _
 _
##gray|@@//@@ a not modified:## _
a2 := Append(a, 9); _
##gray|@@//@@ a2 not modified:## _
a3 := Prune(a2); _
##gray|@@//@@ a modified:## _
Append(~a, 9); _
Prune(~a);||a = [6, 7, 8]; _
Add(a, 9); _
elem := Remove(a);||list a = list(6, 7, 8); _
list a2 = insert(a, 9, size(a)); _
int popme = a2[size(a2)]; _
list a3 = delete(a2, size(a2));||
||[[# array-front]][#array-front-note manipulate front]||a = List([6, 7, 8]); _
listinsert(a, 5, 1); _
elem = a[1]; _
listpop(a, 1);|| || || ||
||[[# array-head]][#array-head-note head] _
@<&nbsp;>@||List([1, 2, 3])[1]|| || || ||
||[[# array-tail]][#array-tail-note tail] _
@<&nbsp;>@||##gray|//none//##|| || || ||
||[[# array-cons]][#array-cons-note cons]||a = List([1, 2, 3]); _
listinsert(a, 1, 1);|| || || ||
||[[# array-concatenate]][#array-concatenate-note concatenate] _
@<&nbsp;>@||concat(List([1, 2, 3]), List([4, 5, 6]))|| ||Concatenation([1, 2, 3], [4, 5, 6]);||list a1 = 1, 2, 3; _
list a2 = 4, 5, 6; _
list a3 = a1 + a2;||
||[[# array-replicate]][#array-replicate-note replicate] _
@<&nbsp;>@|| || || || ||
||[[# copy-array]][#copy-array-note copy] _
@<&nbsp;>@||a2 = a|| || || ||
||[[# iterate-over-array]][#iterate-over-array-note iterate] _
@<&nbsp;>@||a = List([1, 2, 3]) _
 _
for(i=1, length(a), print(a[i]))|| ||Perform([1, 2, 3], function(x) Print(x); Print("\n"); end);|| ||
||[[# reverse-array]][#reverse-array-note reverse] _
@<&nbsp;>@||a = List([1, 2, 3]) _
a2 = listcreate() _
while(i > 0, listput(a2, a[i]); i--)|| ||Reversed([1, 2, 3])|| ||
||[[# sort-array]][#sort-array-note sort]||a = List([3,1,4,2]) _
listsort(a) _
a|| ||A := [3, 1, 4, 2] _
Sort(A);|| ||
||[[# dedupe-array]][#dedupe-array-note dedupe] _
@<&nbsp;>@||Set([1, 2, 2, 3])|| ||Set([1, 2, 2, 3]); _
Unique([1, 2, 2, 3]);|| ||
||[[# membership]][#membership-note membership] _
@<&nbsp;>@||##gray|@@\\@@ returns 1-based index of first occurrence _
@@\\@@ or 0 if not found:## _
setsearch([1, 2, 3], 2)|| ||2 in [1, 2, 3]|| ||
||[[# intersection]][#intersection-note intersection] _
@<&nbsp;>@||setintersect([1, 2], [2, 3, 4])|| ||Intersection(Set([1, 2]), Set([2, 3, 4]));|| ||
||[[# union]][#union-note union] _
@<&nbsp;>@||setunion([1, 2], [2, 3, 4])|| ||Union(Set([1, 2]), Set([2, 3, 4]));|| ||
||[[# set-diff]][#set-diff-note relative complement, symmetric difference]||setminus([1, 2, 3], [2]) _
##gray|//??//##|| || || ||
||[[# map]][#map-note map]||apply(x -> x * x, [1, 2, 3])|| ||A := [1, 2, 3]; _
 _
##gray|# modifies A:## _
Apply(A, x -> x * x);|| ||
||[[# filter]][#filter-note filter] _
@<&nbsp;>@||select(x -> x > 2, [1, 2, 3])|| || || ||
||[[# reduce]][#reduce-note reduce] _
@<&nbsp;>@|| || || || ||
||[[# universal-existential-test]][#universal-existential-test-note universal and existential tests]|| || || || ||
||[[# min-max-elem]][#min-max-elem-note min and max element]||vecmin([1, 2, 3]) _
vecmax([1, 2, 3])|| ||Minimum([1, 2, 3]) _
Maximum([1, 2, 3])|| ||
||[[# shuffle-sample]][#shuffle-sample-note shuffle and sample]|| || ||Shuffle([1, 2, 3, 4])|| ||
||[[# flatten]][#flatten-note flatten] _
##gray|//one level, completely//##|| || ||##gray|# completely:## _
Flat([1, [2, [3, 4]]])|| ||
||[[# zip]][#zip-note zip]|| || || || ||
||[[# cartesian-product]][#cartesian-product-note cartesian product]|| || ||Cartesian([1, 2, 3], ["a", "b", "c"])|| ||
||||||||||~ [[# sets]][#sets-note sets]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# set-literal]][#set-literal-note literal]||##gray|@@\\@@ sets are vectors whose _
@@\\@@ elements are strictly increasing## _
Set([1, 2, 3])||{1, 2, 3};|| || ||
||[[# set-size]][#set-size-note size]||#Set([1, 2, 3])||# {1, 2, 3};|| || ||
||[[# set-add-elem]][#set-add-elem-note add element]|| ||s := {1, 2, 3}; _
Inlude(~s, 4);|| || ||
||[[# set-rm-elem]][#set-rm-elem-note remove element]|| ||s := {1, 2, 3}; _
Exclude(~s, 1);|| || ||
||[[# set-membership]][#set-membership-note membership test]||##gray|@@\\@@ returns 1-based index of first occurrence _
@@\\@@ or 0 if not found:## _
setsearch([1, 2, 3], 2)||7 in {6, 7, 8};|| || ||
||[[# disjoint-test]][#disjoint-test-note disjoint test]|| ||IsDisjoint({1, 2, 3}, {2, 3, 4});|| || ||
||[[# set-union]][#set-union-note union]||setunion([1, 2], [2, 3, 4])||##gray|@@//@@ {1, 2, 3, 4}:## _
s := {1, 2, 3} join {2, 3, 4};|| || ||
||[[# set-intersection]][#set-intersection-note intersection]||setintersect([1, 2], [2, 3, 4])||##gray|@@//@@ {2, 3}:## _
s := {1, 2, 3} meet {2, 3, 4};|| || ||
||[[# set-relative-complement]][#set-relative-complement-note relative complement]||setminus([1, 2, 3], [2])||##gray|@@//@@ {1}:## _
s := {1, 2, 3} diff {2, 3, 4};|| || ||
||||||||||~ [[# arith-seq]][#arith-seq-note arithmetic sequences]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[#range unit difference]||[1 .. 100] _
vector(100, i, i)||[1 .. 100];||[1 .. 100]|| ||
||[#arithmetic-sequence-integer difference of 10]||vector(10, i, 10 * i  - 9)||[1 .. 100 by 10];||[1,11 .. 91]|| ||
||[#airthmetic-sequence-float difference of 0.1]||vector(1000 - 9, i, i / 10 + 9 / 10)||[0.1 * i: i in [1 .. 1000]];||##gray|//none//##|| ||
||||||||||~ [[# dictionaries]][#dictionaries-note dictionaries]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# dict-literal]][#dict-literal-note literal] _
@<&nbsp;>@||d = Map(["t", 1; "f", 0])||##gray|@@//@@ None, just empty constructor:## _
d := AssociativeArray(); _
d["t"] := 1; _
d["f"] := 0;||##gray|# dictionary constructor; type of keys derived _
# from first arg:## _
d := NewDictionary("", true); _
AddDictionary(d, "t", 1); _
AddDictionary(d, "f", 0); _
 _
##gray|# record literal with identifier keys: ## _
r := rec(t := 1, f := 0); _
 _
##gray|# record literal with string keys:## _
r2 := rec(("t") := 1, ("f") := 0);|| ||
||[[# dict-size]][#dict-size-note size] _
@<&nbsp;>@||#d||# d;||##gray|# no way to get size of dictionary?## _
  _
Length(RecNames(r));|| ||
||[[# dict-lookup]][#dict-lookup-note lookup] _
@<&nbsp;>@||mapget(d, "t")||d["t"];||LookupDictionary(d, "t"); _
 _
##gray|# the same key can be looked up with identifier _
# or string notation:## _
r.t; _
r.("t");|| ||
||[[# dict-update]][#dict-update-note update]||mapput(d, "f", -1)||d["f"] := -1;||AddDictionary(d, "f", -1); _
 _
r.f := -1; _
r2.("f") := -1;|| ||
||[[# dict-missing-key]][#dict-missing-key-note missing key behavior] _
@<&nbsp;>@||##gray|mapget //raises error//##||##gray|//Runtime error//##||##gray|# returns special object "fail":## _
LookupDictionary(d, "not_a_key"); _
 _
##gray|# raises an error:## _
r.not_a_key;|| ||
||[[# dict-key-check]][#dict-key-check-note is key present] _
@<&nbsp;>@||mapisdefined(d, "t")||IsDefined(d, "t");||KnowsDictionary(d, "t"); _
 _
##gray|# RecNames returns keys as strings:## _
"t" in RecNames(r);|| ||
||[[# dict-del]][#dict-del-note delete]||mapdelete(d, "t")||Remove(~d, "t");|| || ||
||[[# dict-iter]][#dict-iter-note iterate] _
@<&nbsp;>@|| || ||##gray|# no way to iterate over dictionary?## _
 _
for i in RecNames(r) do _
@<&nbsp;&nbsp;>@Print(r.(i)); _
od;|| ||
||[[# dict-key-val]][#dict-key-val-note keys and values as arrays]|| ||Keys(d); _
##gray|//??//##||RecNames(r);|| ||
||||||||||~ [[# functions]][#functions-note functions]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[#function-definition define function]||add(x, y) = x + y _
 _
##gray|@@\\@@ function body w/ sequence of statements:## _
say(s1, s2, s3) = print(s1); print(s2); print(s3) _
 _
##gray|@@\\@@ function body w/ newlines:## _
dire(s1, s2, s3) = { _
@<&nbsp;&nbsp;>@print(s1); _
@<&nbsp;&nbsp;>@print(s2); _
@<&nbsp;&nbsp;>@print(s3); _
}||add := function(a, b) _
@<&nbsp;&nbsp;>@return a + b; _
end function; _
 _
##gray|@@//@@ no return value:## _
show := procedure(s) _
@<&nbsp;&nbsp;>@print(s); _
end procedure;||add := function(x, y) _
@<&nbsp;&nbsp;>@return x + y; _
end;||proc add(int x, int y) { _
@<&nbsp;&nbsp;>@return(x + y); _
}||
||[#function-invocation invoke function]||add(3, 7)||add(3, 7);||add(3, 7);||add(3, 7);||
||[[# undef-func]][#undef-func-note undefine function]||kill(add)|| || || ||
||[[# redefine-func]][#redefine-func-note redefine function]||add(x, y, z) = x + y + z|| || || ||
||[[# overload-func]][#overload-func-note overload function]||##gray|//none//##|| || || ||
||[[# missing-func]][#missing-func-note missing function behavior]||##gray|//"not a function" error//##|| || || ||
||[[# missing-arg]][#missing-arg-note missing argument behavior]||##gray|//set to zero//##|| || || ||
||[[# extra-arg]][#extra-arg-note extra argument behavior]||##gray|//"too many parameters" error//##|| || || ||
||[[# default-arg]][#default-arg-note default argument]||mylog(x = 1, base = 10) = log(x) / log(base) _
 _
##gray|@@\\@@ log10(3):## _
mylog(3) _
##gray|@@\\@@ ln(3):## _
mylog(3, exp(1)) _
##gray|@@\\@@ ln(1):## _
mylog(, exp(1)) _
 _
##gray|@@\\@@ If neither caller nor function definition _
@@\\@@ provide a value, zero is used.##|| || || ||
||[[# retval]][#retval-note return value]|| || || || ||
||[#anonymous-function anonymous function]||f = (x, y) -> x + y _
 _
f(1, 2)|| ||##gray|# unary functions only?## _
f := x -> x * x; _
 _
f2 := function(x, y) return 2 * x + 3 * y; end;|| ||
||[#variable-number-arguments variable number of arguments]|| || || || ||
||[[# expand-array]][#expand-array-note pass array elements as separate arguments]|| || || || ||
||||||||||~ [[# execution-control]][#execution-control-note execution control]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[#if if]||if(x > 0, \ _
@<&nbsp;&nbsp;>@print("positive"), \ _
@<&nbsp;&nbsp;>@if(x < 0, \ _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@print("negative"), \ _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@print("zero")))||if n gt 0 then _
@<&nbsp;&nbsp;>@print "positive"; _
else _
@<&nbsp;&nbsp;>@if n lt 0 then _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@print "negative"; _
@<&nbsp;&nbsp;>@else _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@print "zero"; _
@<&nbsp;&nbsp;>@end if; _
end if;||if x > 0 then _
@<&nbsp;&nbsp;>@Print("positive\n"); _
elif x < 0 then _
@<&nbsp;&nbsp;>@Print("negative\n"); _
else _
@<&nbsp;&nbsp;>@Print("zero\n"); _
fi;||int x = -3; _
if (x > 0) { _
@<&nbsp;&nbsp;>@print("positive"); _
} else { if (x < 0) { _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@print("negative"); _
@<&nbsp;&nbsp;>@} else { _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@print("zero"); _
@<&nbsp;&nbsp;>@} _
};||
||[#while while]||i = 0 _
while(i < 10, print(i); i++)||i := 0; _
while i lt 10 do _
@<&nbsp;&nbsp;>@print i; _
@<&nbsp;&nbsp;>@i := i + 1; _
end while;||i := 0; _
while i < 10 do _
@<&nbsp;&nbsp;>@Print(i, "\n"); _
@<&nbsp;&nbsp;>@i := i + 1; _
od;||int i = 0; _
while (i < 10) { _
@<&nbsp;&nbsp;>@print(i); _
@<&nbsp;&nbsp;>@i++; _
};||
||[#for for]||for(i = 0, 9, print(i))||for i := 0 to 9 by 1 do _
@<&nbsp;&nbsp;>@print i; _
end for;||for i in [0..9] do _
@<&nbsp;&nbsp;>@Print(i, "\n"); _
od;||int i; _
for (i = 0; i < 10; i++) { _
@<&nbsp;&nbsp;>@print(i); _
};||
||[#break break]||break|| ||break||break||
||[#continue continue]||next|| ||continue||continue||
||||||||||~ [[# exceptions]][#exceptions-note exceptions]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# raise-exc]][#raise-exc-note raise exception]||error("failed")||error "failed";||Error("failed");|| ||
||[[# handle-exc]][#handle-exc-note handle exception]||iferr(error("failed"), E, \ _
@<&nbsp;&nbsp;>@print(errname(E), ": ", component(E, 1)))||try _
@<&nbsp;&nbsp;>@error "failed"; _
catch e _
@<&nbsp;&nbsp;>@print "caught error"; _
end try;|| || ||
||[[# uncaught-exc]][#uncaught-exc-note uncaught exception behavior]|| || ||##gray|Error() //invokes the GAP debugger.  Type// _
 _
@<&nbsp;&nbsp;>@Quit; _
 _
//to return to REPL.//##|| ||
||||||||||~ [[# streams]][#streams-note streams]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# write-line-stdout]][#write-line-stdout-note write line to stdout]||print("hello")||print "hello";||Print("hello");||print("hello");||
||[#read-file-string-array read file into array of strings]||a = readstr("/etc/hosts")|| || || ||
||||||||||~ [[# processes-env]][#processes-env-note processes and environment]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# env-var]][#env-var-note environment variable]||getenv("HOME")|| || || ||
||[[# external-cmd]][#external-cmd-note external command]||system("ls /etc")|| || || ||
||[[# cmd-subst]][#cmd-subst-note command substitution]||##gray|@@\\@@ array of output lines:## _
lines = externstr("ls /etc")|| || || ||
||||||||||~ [[# libraries-namespaces]][#libraries-namespaces-note libraries and namespaces]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# load-lib]][#load-lib-note load library]|| || ||Read('foo.g');||LIB "add.sing";||
||[[# def-lib]][#def-lib-note define library]|| || || ||$ cat add.sing _
version="1.0" _
category="misc" _
info="an add function" _
 _
proc add(int x, int y) { _
@<&nbsp;&nbsp;>@return(x + y); _
}||
||[[# lib-path]][#lib-path-note library path]|| || || ||##gray|//Searches current directory; additional directories can be added to the search path by adding them separated by colons to the/ SINGULARPATH //environment variable.//##||
||||||||||~ [[# reflection]][#reflection-note reflection]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[#list-function-documentation list function documentation]||?|| || || ||
||[#function-documentation get function documentation]||? tan|| || ||help killall;||
||[#data-type query data type]||type(x)||Type(x);|| ||typeof(x);||
||[[# list-types]][#list-types-note list types]||\t|| || || ||
||[#list-variables list variables in scope]||variable()|| || ||listvar();||
||[[# list-built-in-func]][#list-built-in-func-note list built-in functions]||?*|| || || ||
||[[# list-metacmds]][#list-metacmds-note list metacommands]||?\|| || || ||
||[[# search-doc]][#search-doc-note search documentation]||??? modulus|| ||??DirectProduct|| ||
||||||||||~ [[# vectors]][#vectors-note vectors]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# vec-literal]][#vec-literal-note vector literal]||[1, 2, 3]|| ||##gray|# row vector is same as array:## _
[1, 2, 3]||##gray|@@//@@ A ring must be declared.  The elements of the vector are not _
@@//@@ limited to the coefficient field, but can be any element of _
@@//@@ the ring.## _
ring r = read, (x), dp; _
 _
vector v= [1.5, 3.2, 7.1];||
||[[# const-vec]][#const-vec-note constant vector] _
 _
##gray|//all zeros, all ones//##||vector(100, i, 0) _
vector(100, i, 1)|| || || ||
||[[# vec-coordinate]][#vec-coordinate-note vector coordinate]||##gray|@@\\@@ indices start at one:## _
[1, 2, 3][1]|| ||vec := [1, 2, 3]; _
##gray|# indices start at one:## _
v[1];||v[1];||
||[[# vec-dim]][#vec-dim-note vector dimension] _
@<&nbsp;>@||length([1, 2, 3]) _
#[1, 2, 3]|| ||Length([1, 2, 3])||nrows(v);||
||[[# vec-element-wise]][#vec-element-wise-note element-wise arithmetic operators]||+ -|| ||+ - * /||+ -||
||[[# vec-length-mismatch]][#vec-length-mismatch-note vector length mismatch] _
@<&nbsp;>@||##gray|//error//##|| ||##gray|//shorter vector is zero-padded//##||##gray|//shorter vector is zero-padded//##||
||[[# vec-scalar]][#vec-scalar-note scalar multiplication]||3 * [1, 2, 3] _
[1, 2, 3] * 3|| ||3 * [1, 2, 3]; _
[1, 2, 3] * 3;||3 * v; _
v * 3; _
 _
##gray|@@//@@ Scalar can be any ring element:## _
(1 + x) * v;||
||[[# vec-dot]][#vec-dot-note dot product]||[1, 1, 1] * [2, 2, 2] ~|| ||[1, 1, 1] * [2, 2, 2]|| ||
||[[# vec-cross]][#vec-cross-note cross product]|| || || || ||
||[[# vec-norms]][#vec-norms-note norms]||vec = [1, 2, 3] _
 _
normlp(vec, 1) _
normlp(vec, 2) _
normlp(vec)|| || || ||
||[[# orthonormal-basis]][#orthonormal-basis-note orthonormal basis]|| || || || ||
||||||||||~ [[# matrices]][#matrices-note matrices]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# matrix-literal-constructor]][#matrix-literal-constructor-note literal]||[1, 2; 3, 4] _
 _
##gray|@@\\@@ from rows:## _
row1 = [1, 2] _
row2 = [3, 4] _
matconcat([row1; row2])|| ||[[1, 2], [3, 4]]||##gray|@@//@@ A ring must be declared.  The elements of the matrix are not _
@@//@@ limited to the coefficient field, but can be any element of _
@@//@@ the ring.## _
ring r = read, (x), dp; _
 _
matrix m[2][2] = 1, 2, 3, 4;||
||[[# matrix-from-cols]][#matrix-from-cols-note construct from columns]||col1 = [1, 3]~ _
col2 = [2, 4]~ _
matconcat([col1, col2])|| || || ||
||[[# matrix-from-submatrices]][#matrix-from-submatrices-note construct from submatrices]||A = [1, 2; 3, 4] _
B = [4, 3; 2, 1] _
##gray|@@\\@@ 4x4 matrix:## _
C = matconcat([A, B; B, A])|| || || ||
||[[# const-matrices]][#const-matrices-note constant matrices]||matrix(3, 3, i, j, 0) _
matrix(3, 3, i, j, 1) _
 _
##gray|@@\\@@ 3x3 Hilbert matrix:## _
matrix(3, 3, i, j, 1 / (i + j - 1))|| || || ||
||[[# diagonal-matrices]][#diagonal-matrices-note diagonal matrices] _
##gray|//and identity//##||matdiagonal([1, 2, 3]) _
matid(3)|| ||DiagonalMat([1, 2, 3]) _
IdentityMat(3)|| ||
||[[# matrix-dim]][#matrix-dim-note dimensions]||##gray|@@\\@@ [3, 2]:## _
matsize([1, 2; 3, 4; 5, 6])|| ||##gray|# returns [3, 2]:## _
DimensionsMat([[1, 2], [3, 4], [5, 6]])||nrows(m); _
ncols(m);||
||[[# element-lookup]][#element-lookup-note element lookup]||##gray|@@\\@@ top left corner:## _
A[1, 1]|| ||A := [[1, 2], [3, 4]];  _
 _
##gray|# top left corner:## _
A[1][1]||matrix m[2][2] = 1, 2, 3, 4; _
 _
m[1][1];||
||[[# extract-matrix-row]][#extract-matrix-row-note extract row]||##gray|@@\\@@ first row:## _
[1, 2; 3, 4][1, ]|| || || ||
||[[# extract-matrix-col]][#extract-matrix-col-note extract column]||##gray|@@\\@@ first column:## _
[1, 2; 3, 4][, 1]|| || || ||
||[[# extract-submatrix]][#extract-submatrix-note extract submatrix]||A = [1, 2, 3; 4, 5, 6; 7, 8, 9] _
 _
vecextract(A, "1..2", "1..2")|| || || ||
||[[# matrix-elem-wise-op]][#matrix-elem-wise-op-note element-wise operators]||+ -|| ||+ -||+ -||
||[[# matrix-mult]][#matrix-mult-note product]||A = [1, 2; 3, 4] _
B = [4, 3; 2, 1] _
A * B|| ||A := [[1, 2], [3, 4]]; _
B := [[4, 3], [2, 1]]; _
A * B;||matrix m[2][2] = 1, 2, 3, 4; _
matrix m2[2][2] = 4, 3, 2, 1; _
 _
m * m2;||
||[[# matrix-power]][#matrix-power-note power]||[1, 2; 3, 4] ^ 3|| || [[1, 2], [3, 4]] ^ 3|| ||
||[[# matrix-exponential]][#matrix-exponential-note exponential]|| || || || ||
||[[# matrix-log]][#matrix-log-note log]|| || || || ||
||[[# kronecker-prod]][#kronecker-prod-note kronecker product]|| || ||A := [[1, 2], [3, 4]]; _
B := [[4, 3], [2, 1]]; _
KroneckerProduct(A, B);|| ||
||[[# matrix-norm]][#matrix-norm-note norms]|| || || || ||
||[[# matrix-transpose]][#matrix-transpose-note transpose]||A~ _
mattranspose(A)|| || || ||
||[[# matrix-conjugate-transpose]][#matrix-conjugate-transpose-note conjugate transpose]||conj([1, I; 2, -I] ~)|| || || ||
||[[# matrix-inverse]][#matrix-inverse-note inverse]||[1, 2; 3, 4] ^ -1 _
1 /  [1, 2; 3, 4]|| ||Inverse([[1, 2], [3, 4]])|| ||
||[[# row-echelon-form]][#row-echelon-form-note row echelon form]|| || || || ||
||[[# pseudoinverse]][#pseudoinverse-note pseudoinverse]|| || || || ||
||[[# determinant]][#determinant-note determinant]||matdet([1, 2; 3, 4])|| ||Determinant([[1, 2], [3, 4]])||matrix m[2][2] = 1, 2, 3, 4; _
 _
det(m);||
||[[# trace]][#trace-note trace]||trace([1, 2; 3, 4])|| ||Trace([[1, 2], [3, 4]])||matrix m[2][2] = 1, 2, 3, 4; _
 _
trace(m);||
||[[# matrix-rank]][#matrix-rank-note rank]||matrank([1, 1; 0, 0])|| ||RankMat([[1, 1], [0, 0]])|| ||
||[[# nullspace-basis]][#nullspace-basis-note nullspace basis]||matker([1, 1; 0, 0])|| || || ||
||[[# range-basis]][#range-basis-note range basis]|| || ||matimage([1, 1; 0, 0])|| ||
||[[# eigenval]][#eigenval-note eigenvalues]||[vals, vecs] = mateigen([1, 2; 3, 4], flag=1)|| || || ||
||[[# eigenvec]][#eigenvec-note eigenvectors]||mateigen([1, 2; 3, 4])|| || || ||
||[[# svd]][#svd-note singular value decomposition]|| || || || ||
||[[# qr-decomposition]][#qr-decomposition-note qr decomposition]||matqr([1, 2; 3, 4])|| || || ||
||[[# solve-linear-eqns]][#solve-linear-eqns-note solve system of equations]||A = [1, 2; 3, 4] _
matsolve(A, [2, 3]~)|| || || ||
||||||||||~ [[# combinatorics]][#combinatorics-note combinatorics]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# factorial]][#factorial-note factorial]||10!||Factorial(10);||Factorial(10);||LIB "general.lib"; _
 _
factorial(10);||
||[[# binomial-coefficient]][#binomial-coefficient-note binomial coefficient]||binomial(10, 3)||Binomial(10, 3);||Binomial(10, 3);||LIB "general.lib"; _
 _
binomial(10, 3);||
||[[# multinomial-coefficient]][#multinomial-coefficient-note multinomial coefficient]|| ||Multinomial(12, [3, 4, 5]);|| || ||
||[[# int-partitions]][#int-partitions-note integer partitions] _
 _
##gray|//and count//##||partitions(10) _
 _
length(partitions(10))||Partitions(10); _
 _
NumberOfPartitions(10);||Partitions(10); _
 _
NrPartitions(10);|| ||
||[[# set-partitions]][#set-partitions-note set partitions] _
 _
##gray|//and Bell number//##||stirling(10, 3, 2) _
sum(i=1, 10, stirling(10, i, 2))||StirlingSecond(10, 3); _
 _
Bell(10);|| || ||
||[[# permutations-k-disjoint-cycles]][#permutations-k-disjoint-cycles-note permutations with k disjoint cycles]||abs(stirling(n, k, 1))||Abs(StirlingFirst(n, k));|| || ||
||[[# fibonacci-num]][#fibonacci-num-note fibonacci number] _
 _
##gray|//and lucas number//##||fibonacci(10)||Fibonacci(10); _
Lucas(10);|| || ||
||[[# bernoulli-num]][#bernoulli-num-note bernoulli number]||bernfrac(100)||BernoulliNumber(100);|| || ||
||[[# catalan-num]][#catalan-num-note catalan number]|| ||Catalan(10);|| || ||
||||||||||~ [[# number-theory]][#number-theory-note number theory]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# pseudoprime-test]][#pseudoprime-test-note pseudoprime test]||ispseudoprime(7)||IsProbablyPrime(7);||IsPrimeInt(7);|| ||
||[[# true-prime-test]][#true-prime-test-note true prime test] _
@<&nbsp;>@||isprime(7)||IsPrime(7);|| || ||
||[[# divisors]][#divisors-note divisors]||divisors(100)||##gray|@@//@@ [1, 2, 4, 5, 10, 20, 25, 50, 100]:## _
Divisors(100); ||DivisorsInt(100);|| ||
||[[# prime-factors]][#prime-factors prime factors]||##gray|@@\\@@ [2,2; 3,1; 7,1]:## _
factor(84)||##gray|@@//@@ [2, 3, 7]:## _
PrimeDivisors(84);||##gray|# [ 2, 2, 3, 7 ]:## _
FactorsInt(84);|| ||
||[[# next-prime]][#next-prime-note next prime] _
 _
##gray|//and preceding//##||nextprime(1000) _
precprime(1000)||NextPrime(1000); _
PreviousPrime(1000);||NextPrimeInt(1000); _
PrevPrimeInt(1000);||##gray|//?//## _
prime(1000);||
||[[# nth-prime]][#nth-prime-note nth prime]||##gray|@@\\@@ first 100 primes: primes(100)## _
primes(100)[100]||NthPrime(100);|| || ||
||[[# prime-counting-func]][#prime-counting-func-note prime counting function]||primepi(100)|| || ||LIB "general.lib"; _
 _
size(primes(1, 100));||
||[[# divmod]][#divmod-note divmod] _
@<&nbsp;>@||divrem(7, 3)|| || || ||
||[[# gcd]][#gcd-note greatest common divisor] _
 _
##gray|//and relatively prime test//##||gcd(14, 21) _
gcd(gcd(14, 21), 777)||Gcd(14, 21); _
Gcd(Gcd(14, 21), 777);||GcdInt(14, 21); _
GcdInt(GcdInt(14, 21), 777);|| ||
||[[# extended-euclidean-algorithm]][#extended-euclidean-algorithm-note extended euclidean algorithm]||##gray|@@\\@@ [2, -1, 1]:## _
gcdext(3, 5)|| ||ret := Gcdex(3, 5); _
 _
##gray|# 2:## _
ret.coeff1; _
##gray|# -1:## _
ret.coeff2; _
##gray|# 1:## _
ret.gcd;|| ||
||[[# lcm]][#lcm-note least common multiple]||lcm(14, 21)||Lcm(14, 21);||LcmInt(14, 21);|| ||
||[[# int-residues]][#int-residues-note integer residues]||Mod(2, 5) + Mod(3, 5) _
Mod(2, 5) - Mod(3, 5) _
Mod(2, 5) * Mod(3, 5) _
Mod(2, 5)^2|| ||r := ZmodnZ(5); _
fam := ElementsFamily(FamilyObj(r));; _
 _
ZmodnZObj(fam, 2) + ZmodnZObj(fam, 3);|| ||
||[[# mult-inverse]][#mult-inverse-note multiplicative inverse]||Mod(2, 7)^-1 _
 _
##gray|@@\\@@ raises error:## _
Mod(2, 4)^-1|| ||r := ZmodnZ(7); _
fam := ElementsFamily(FamilyObj(r));; _
 _
ZmodnZObj(2, 7)^-1;|| ||
||[[# chinese-remainder-thm]][#chinese-remainder-thm-note chinese remainder theorem]||##gray|@@\\@@ Mod(173, 187):## _
chinese(Mod(3, 17), Mod(8, 11))|| ||##gray|# 173:## _
ChineseRem([17, 11], [3, 8]);|| ||
||[[# lift-int-residue]][#lift-int-residue-note lift integer residue]||##gray|@@\\@@ 7:## _
lift(-17, 12) _
##gray|@@\\@@ -5:## _
centerlift(-17, 12)|| || || ||
||[[# euler-totient]][#euler-totient-note euler totient] _
@<&nbsp;>@||eulerphi(256)|| ||Phi(256);|| ||
||[[# mult-order]][#mult-order-note multiplicative order]||znorder(Mod(7, 108))|| ||OrderMod(7, 108);|| ||
||[[# primitive-roots]][#primitive-roots-note primitive roots]||znprimroot(11)|| ||PrimitiveRootMod(11);|| ||
||[[# discrete-log]][#discrete-log-note discrete logarithm]||znlog(10, Mod(2, 11)) _
znlog(Mod(10, 11), Mod(2, 11))|| ||##gray|# arg: 10, base: 2, modulus: 11## _
LogMod(10, 2, 11);|| ||
||[[# carmichael-func]][#carmichael-func-note carmichael function]||lcm(znstar(561)[2])|| ||Lambda(561);|| ||
||[[# kronecker-symbol]][#kronecker-symbol-note kronecker symbol] _
 _
##gray|//and jacobi symbol//##||kronecker(3, 5)|| ||Jacobi(3, 5);|| ||
||[[# moebius-func]][#moebius-func-note moebius function]||moebius(11)||MoebiusMu(11);||MoebiusMu(11);|| ||
||[[# riemann-zeta-func]][#riemann-zeta-func-note riemann zeta function]||zeta(2)|| || || ||
||[[# mangoldt-lambda]][#mangoldt-lambda-note mangoldt lambda]|| || || || ||
||[[# dirichlet-char]][#dirichlet-char-note dirichlet character]|| || || || ||
||||||||||~ [[# elliptic-curves]][#elliptic-curves-note elliptic curves]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||elliptic curve from coefficients||##gray|@@\\@@ ellinit([a, b, c, d, e]) where _
@@\\@@ _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@y^2 + axy + by = x^3 + cx^2 + dx + e _
@@\\@@## _
e0 = ellinit([0,0,1,-7,6]) _
 _
##gray|@@\\@@ ellinit([a, b]) where _
@@\\@@ _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@y^2 = x^3 + ax + b _
@@\\@@## _
e1 = ellinit([-1, 0])|| || || ||
||discriminant||e0.disc|| || || ||
||conductor||ellglobalred(e0)[1]|| || || ||
||singularity test||e0.disc == 0|| || || ||
||convert to minimal model||e0 = ellinit([6, -3, 9, -16, -14]) _
e = ellminimalmodel(e0)|| || || ||
||coordinate transformation on point||e0 = ellinit([6, -3, 9, -16, -14]) _
e = ellminimalmodel(e0, &v) _
##gray|@@\\@@ minimal to original:## _
ellchangepointinv([0, 0], v) _
##gray|@@\\@@ original to minimal:## _
ellchangepoint([-2, 2], v)|| || || ||
||coordinate transformation on curve: ellchangecurve||e0 = ellinit([6, -3, 9, -16, -14]) _
e = ellminimalmodel(e0, &v) _
##gray|@@\\@@ same as e0:## _
ellchangecurve(e, v)|| || || ||
||point on curve test||ellisoncurve(e, [0, 2])|| || || ||
||abscissa to ordinates||##gray|@@\\@@ vector of size 0, 1, or 2:## _
ellordinate(e, 0)|| || || ||
||group identity||[0]|| || || ||
||group operation||elladd(e, [0, 2], [1, -1])|| || || ||
||group inverse||ellneg(e, [0, 2])|| || || ||
||group multiplication||ellmul(e, [0, 2], 3)|| || || ||
||canonical height of point||ellheight(e, [0, -3])|| || || ||
||order of point||##gray|@@\\@@ returns 0 for infinite order:## _
ellorder(e, [0, 2]) _
 _
ellorder(e1, [0, 0])|| || || ||
||torsion subgroup||e1 = ellinit([-1, 0]) _
 _
##gray|@@\\@@ returns [t, v1, v2]: _
@@\\@@ _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@t: order of torsion group _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@v1: orders of component cyclic groups _
@@\\@@@<&nbsp;&nbsp;&nbsp;>@v2: generators of same cyclic groups _
@@\\@@## _
elltors(e1)|| || || ||
||analytic rank||##gray|@@\\@@ first value is rank:## _
[a, b] = ellanalyticrank(e) _
 _
##gray|@@\\@@ recompute second value to higher precision:## _
\p 100 _
b = ellL1(e, a)|| || || ||
||L-function value||elllseries(e, 1 + I)|| || || ||
||L-function coefficients||##gray|@@\\@@ tenth coefficient:## _
ellak(e, 10) _
##gray|@@\\@@ first ten coefficients:## _
ellan(e, 10)|| || || ||
||||||||||~ [[# rational-algebraic-numbers]][#rational-algebraic-numbers-note rational and algebraic numbers]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||to continued fraction||\p 100 _
contfrac(Pi)|| || || ||
||from continued fraction|| || || || ||
||p-adic number||##gray|@@\\@@ p is 2 and precision in powers of 2 is 100:## _
1/2 + O(2^100)|| || || ||
||lift p-adic to rational||lift(1/2 + O(2^100))|| || || ||
||gaussian integer norm||norm(1 + I)|| || || ||
||quadratic extension||##gray|@@\\@@ make w equal to sqrt(D)/4:## _
D = -4 _
w = quadgen(D)|| || || ||
||quadratic number||(1 + w)^2|| || || ||
||||||||||~ [[# polynomials]][#polynomials-note polynomials]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||from expression with indeterminates||(x - 1) * (x - 2) _
 _
(1+x)^2 * (2+y)^3|| || ||##gray|@@//@@ A ring must be declared before a polynomial can be defined. _
@@//@@ To define a ring, one specifies (1) the coefficient field _
@@//@@ (or ring), (2) the indeterminate variables, and (3) the term _
@@//@@ ordering.## _
ring r = integer, (x, y), dp; _
 _
poly p1 = (x - 1) * (x - 2); _
poly p2 = (1 + x)^2 * (2 + y)^3;||
||from coefficient array||Pol([1, -3, 2]) _
 _
##gray|@@\\@ zero-degree coefficient first:## _
Polrev([2, -3, 1])|| || || ||
||to coefficient array||Vec((x+1)^10)|| || ||poly p = (1 + x)^10; _
coeffs(p, x);||
||lookup coefficient||polcoeff((x+1)^10, 3)|| || || ||
||substitute indeterminate||##gray|@@\\@@ replace x with 3:## _
subst((x-1)*(x-2), x, 3) _
##gray|@@\\@@ replace x with (x-1):## _
subst((x-1)*(x-2), x, (x-1))|| || ||subst((x - 1) * (x - 2), x, 3); _
 _
subst((x - 1) * (x - 2), x, (x - 1));||
||degree||poldegree((x-1)^10)|| || ||poly p = (1 + x)^10; _
deg(p);||
||operations||+ - * /|| || || ||
||division and remainder|| || || || ||
||[#expand-polynomial expand polynomial]|| || || ||##gray|//Polynomials are displayed in expanded form.//##||
||[#factor-polynomial factor polynomial]|| || || || ring r = 7, (x), dp; _
 _
##gray|@@//@@ Doesn't work in ring with real or int. coefficients:## _
factorize(x^2 + 3*x + 2);||
||collect terms|| || || ||ring r = integer, (x, y), dp; _
 _
coeffs((x + 2*y + 1)^10, x);||
||factor||factor(x^2-1)|| || || ||
||roots||polroots(x^3+3*x^2+2*x-1)|| || || ||
||greatest common divisor||p1 = x^3 + 2*x^2 -x -2 _
p2 = x^3 -7*x + 6 _
gcd(p1, p2)|| || || ||
||resultant||polresultant((x-1)*(x-2), (x-3)^2)|| || || ||
||discriminant||poldisc((x+1)*(x-2))|| || || ||
||homogenity test|| || || ||homog((x + y)^2);||
||groebner basis||##gray|//none//##|| || || ||
||specify ordering||##gray|//none//##|| || || ||
||symmetric polynomial||##gray|//none//##|| || || ||
||cyclotomic polynomial||polcyclo(10)|| || || ||
||hermite polynomial||polhermite(4)|| || || ||
||chebyshev polynomial _
 _
##gray|//first and second kind//##||polchebyshev(4, 1) _
polychebyshev(4, 2)|| || || ||
||interpolation polynomial||polinterpolate([1, 2, 3], [2, 4, 7])|| || || ||
||characteristic polynomial||charpoly([1, 2; 3, 4])|| || || ||
||minimal polynomial|| || || || ||
||piecewise polynomial|| || || || ||
||rational function||(x - 1) / (x - 2)^2|| || || ||
||[#add-fractions add fractions]|| || || || ||
||[#partial-fraction-decomposition partial fraction decomposition]|| || || || ||
||||||||||~ [[# special-functions]][#special-functions-note special functions]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||gamma||gamma(1/2)|| || || ||
||hyperbolic||sinh cosh tanh|| || || ||
||elliptic integerals|| || || || ||
||bessel functions||besselh1 besselh2 besseli besselj besseljh besselk besseln|| || || ||
||[[# riemann-zeta]][#riemann-zeta-note Riemann zeta]||zeta(2)|| || || ||
||||||||||~ [[# permutations]][#permutations-note permutations]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||permutation from disjoint cycles|| ||S4 := Sym(4); _
p := S4!(1, 2)(3, 4);||p := (1, 2)(3, 4);|| ||
||permutation from list|| ||S4 := Sym(4); _
p2 := elt<S4 | 2, 1, 4, 3>;||p2 := PermList([2, 1, 4, 3]);|| ||
||permutation from two lists|| || ||##gray|# must be positive integers:## _
p := MappingPermListList([6, 8, 4, 2], [2, 4, 6, 8])|| ||
||act on element|| || ||1 ^ p; _
 _
##gray|# preimage of 1 under p:## _
1 / p;|| ||
||act on list|| || || || ||
||compose|| ||S4 := Sym(4); _
 _
S4!(1,2)(3,4) * S4!(1,3);||(1, 2)(3, 4) * (1, 3);|| ||
||invert|| ||S3 := Sym(3); _
 _
S3!(1,2,3) ^ -1; _
Inverse(S3!(1,2,3));||(1, 2, 3) ^ -1;|| ||
||power|| ||S5 := Sym(5); _
 _
S5!(1,2,3,4,5) ^ 3;||(1, 2, 3, 4, 5) ^ 3;|| ||
||order|| ||S3 := Sym(3); _
 _
Order(S3!(1,2,3));||Order((1, 2, 3));|| ||
||support|| || ||MovedPoints((1, 3, 5)(7, 8));|| ||
||number of inversions|| || || || ||
||parity|| || || || ||
||to inversion vector|| || || || ||
||from inversion vector|| || || || ||
||all permutations|| || || || ||
||random permutation|| || || || ||
||||||||||~ [[# groups]][#groups-note groups]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# named-groups]][#named-groups-note named groups] _
 _
##gray|//symmetric, alternating, cyclic, dihedral//##|| ||S4 := Sym(4); _
A4 := AlternatingGroup(4); _
Z5 := CyclicGroup(5); _
D10 := DihedralGroup(10);||S4 := SymmetricGroup(4); _
A4 := AlternatingGroup(4); _
Z5 := CyclicGroup(5); _
##gray|# argument is order of group, not vertices _
# of polygon:## _
D10 := DihedralGroup(2 * 10);|| ||
||[[# group-by-order]][#group-by-order-note group by order]|| ||NumberOfSmallGroups(8); _
 _
##gray|@@//@@ first group of order 8:## _
G := SmallGroup(8, 1);||##gray|# number of groups of order 8:## _
Length(AllSmallGroups(8)); _
 _
##gray|# first group of order 8:## _
G := AllSmallGroups(8)[1];|| ||
||[[# group-from-permutation-generators]][#group-from-permutation-generators-note group from permutation generators]|| ||S5 := Sym(5); _
p1 := S5!(1, 3, 5, 2); _
p2 := S5!(1, 2); _
G := PermutationGroup<5 | p1, p2>;||G := Group((1, 3, 5, 2), (1, 2)); _
 _
##gray|# or## _
G := GroupWithGenerators([(1, 3, 5, 2), (1, 2)]);|| ||
||[[# direct-prod]][#direct-prod-note direct product]|| ||Z3 := CyclicGroup(3); _
A4 := AlternatingGroup(4); _
G := DirectProduct(z3, a4);||Z3 := CyclicGroup(3); _
A4 := AlternatingGroup(4); _
G := DirectProduct(Z3, A4);|| ||
||[[# free-prod]][#free-prod-note free product] _
@<&nbsp;>@|| || ||F := FreeProduct(CyclicGroup(3), CyclicGroup(2));|| ||
||[[# free-group]][#free-group-note free group]|| || ||##gray|# integers under addition:## _
Z := FreeGroup(1); _
 _
##gray|# free group with 2 generators:## _
F := FreeGroup("a", "b");|| ||
||[[# group-from-presentation]][#group-from-presentation-note group from presentation]|| || ||F := FreeGroup( "a", "b" ); _
G := F / [ F.1^2, F.2^3, (F.1 * F.2)^5 ];|| ||
||[[# all-group-elem]][#all-group-elem-note all elements]|| || ||Perform(Enumerator(Z3), function(e) _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@Print(e); _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@Print("\n"); _
@<&nbsp;&nbsp;>@end);|| ||
||[[# group-generators]][#group-generators-note generators]|| ||S10 := Sym(10); _
Generators(s10); _
 _
##gray|@@//@@ notation for individual generators:## _
S10.1; _
S10.2;||S10 := SymmetricGroup(10); _
##gray|# return generators in an array:## _
GeneratorsOfGroup(S10); _
 _
##gray|# notation for individual generators:## _
S10.1; _
S10.2;|| ||
||[[# group-identity-elem]][#group-identity-elem-note identity element]|| ||Id(G);||Identity(G); _
One(G);|| ||
||[[# random-group-elem]][#random-group-elem-note random element]|| ||Random(G);||Random(G)|| ||
||[[# group-op]][#group-op-note group operation]|| ||e1 := Random(G); _
e2 := Random(G); _
e1 * e2;||e1 := Random(G); _
e2 := Random(G); _
e1 * e2;|| ||
||[[# inverse-group-elem]][#inverse-group-elem-note inverse element]|| ||Inverse(e1); _
##gray|@@//@@ or:## _
e1 ^ -1;||Inverse(e1); _
##gray|# or:## _
e1^-1;|| ||
||[[# generator-word-for-elem]][#generator-word-for-elem-note generator word for element]|| || ||S10 := SymmetricGroup(10); _
Factorization(S10, (1,3,8,10,5,9,2,7));|| ||
||[[# elem-by-generator-word-len]][#elem-by-generator-word-len-note elements by generator word length]|| || ||S6 := SymmetricGroup(6); _
GrowthFunctionOfGroup(S6);|| ||
||[[# group-elem-order]][#group-elem-order-note element order]|| ||D10 := DihedralGroup(10); _
Order(D10.1); _
Order(D10.2);||D10 := DihedralGroup(2 * 10); _
 _
Order(D10.1); _
Order(D10.2);|| ||
||[[# identify-group]][#identify-group-note identify group]|| ||##gray|@@//@@ C2*C4:## _
GroupName(SmallGroup(8, 2)); _
 _
##gray|@@//@@ <8, 1>:## _
IdentifyGroup(CyclicGroup(8));||##gray|# C4 x C2:## _
StructureDescription(AllSmallGroups(8)[2]);|| ||
||[[# group-to-presentation]][#group-to-presentation-note group to presentation]|| ||FPGroup(AlternatingGroup(10));|| || ||
||[[# group-order]][#group-order-note group order]|| ||Order(Sym(4));||Size(SymmetricGroup(4));|| ||
||[[# cyclic-test]][#cyclic-test-note cyclic test]|| ||IsCyclic(AlternatingGroup(10));||IsCyclic(AlternatingGroup(10));|| ||
||[[# abelian-test]][#abelian-test-note abelian test]|| ||IsAbelian(CyclicGroup(10));||IsAbelian(CyclicGroup(10)); || ||
||||||||||~ [[# subgroups]][#subgroups-note subgroups]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||[[# all-subgroups]][#all-subgroups-note all subgroups]|| ||Subgroups(Sym(4));||AllSubgroups(SymmetricGroup(4));|| ||
||[[# subgroup-lattice]][#subgroup-lattice-note subgroup lattice]|| ||SubgroupLattice(Sym(4));||S4 := SymmetricGroup(4); _
lat := LatticeSubgroups(S4); _
DotFileLatticeSubgroups(lat, "lattice.dot"); _
##gray|#  dot -Tpng < lattice.dot > lattice.png##|| ||
||[[# maximal-subgroups]][#maximal-subgroups-note maximal subgroups]|| ||MaximalSubgroups(Sym(4));||MaximalSubgroups(S4);|| ||
||[[# frattini-subgroup]][#frattini-subgroup-note frattini subgroup]|| ||D4 := DihedralGroup(4); _
FrattiniSubgroup(D4);||FrattiniSubgroup(DihedralGroup(2 * 4));|| ||
||[[# subgroup-from-generators]][#subgroup-from-generators-note subgroup from generators]|| || ||G := Group((1, 3, 5, 7), (2, 4)); _
H := Subgroup(G, [(2, 4)]);|| ||
||[[# normal-subgroups]][#normal-subgroups-note normal subgroups]|| ||NormalSubgroups(Sym(4));||NormalSubgroups(S4);|| ||
||cosets|| || ||RightCoset() _
CanonicalRightCosetElement() _
CosetDecomposition() _
RightTraversal(G, U)|| ||
||quotient group|| || || || ||
||center|| ||Z4 := CyclicGroup(4); _
D6 := DihedralGroup(6); _
G := DirectProduct(Z4, D6); _
center := Centre(G);||g := DirectProduct(CyclicGroup(4), DihedralGroup(2 * 6)); _
Center(g);|| ||
||centralizer|| || ||g := SymmetricGroup(5); _
h := Centralizer(g, (1, 3)(4, 5));|| ||
||normalizer|| || ||S4 := SymmetricGroup(4); _
G := Group([(1,2)(3,4)]); _
Normalizer(S4, G);|| ||
||[[# commutator]][#commutator-note commutator]|| || ||##gray|# e1^-1 * e2^-1 * e1 * e2:## _
Comm(e1, e2);|| ||
||commutator subgroup|| || ||G1 := Group((1,2,3),(1,2)); _
G2 := Group((2,3,4),(3,4)); _
CommutatorSubgroup(G1, G2);|| ||
||subgroup test|| || || || ||
||subgroup index|| ||Index(Sym(4), AlternatingGroup(4));||Index(G, H);|| ||
||normal test|| || ||IsNormal(G, H);|| ||
||subnormal test|| || ||IsSubnormal(G, H);|| ||
||nonabelian simple groups|| || ||##gray|# argument is list of orders:## _
AllSmallNonabelianSimpleGroups([1..10000]);|| ||
||simple test|| || ||IsSimple(SymmetricGroup(4));|| ||
||solvable test|| || ||IsSolvable(SymmetricGroup(4));|| ||
||derived series|| || ||DerivedSeriesOfGroup(SymmetricGroup(4));|| ||
||characteristic test|| || ||S4 := SymmetricGroup(4); _
H := Subgroup(s4, [(1,4)(2,3), (1,3)(2,4), (2,4,3)]); _
IsCharacteristicSubgroup(S4, H);|| ||
||semidirect product|| || || || ||
||||||||||~ [[# group-homomorphisms]][#group-homomorphisms-note group homomorphisms]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||all homomorphisms|| || ||S4 := SymmetricGroup(4); _
S3 := SymmetricGroup(3); _
AllHomomorphisms(S3, S4);|| ||
||all homomorphims classes|| || ||AllHomomorphismClasses(S3, S4);|| ||
||endomorphisms and automorphisms|| || ||AllEndomorphisms(S4); _
AllAutomorphisms(S4);|| ||
||homomorphism from generator images|| || ||hom := GroupHomomorphismByImages(S3, S4, _
@<&nbsp;&nbsp;>@[(1,2,3), (1,2)], _
@<&nbsp;&nbsp;>@[(2,3,4), (2,3)]); _
 _
##gray|# uses generators of S3:## _
hom := GroupHomomorphismByImages(S3, S4, _
@<&nbsp;&nbsp;>@[(2,3,4), (2,3)]);|| ||
||surjective test|| || ||IsSurjective(hom);|| ||
||injective test|| || ||IsInjective(hom);|| ||
||bijective test|| || ||IsBijective(hom);|| ||
||kernel|| || ||Kernel(AllHomomorphisms(S3, S4)[1]);|| ||
||image|| || ||Image(AllHomomorphisms(S3, S4)[1]);|| ||
||||||||||~ [[# actions]][#actions-note actions]||
||~ ||~ pari/gp||~ magma||~ gap||~ singular||
||conjugate element|| || ||##gray|# (1,2,3)^-1 * (1,2) * (1,2,3):## _
(1,2)^(1,2,3)|| ||
||conjugate set|| || ||S3 := SymmetricGroup(3); _
S3^(3,4); _
(3,4)^S3;|| ||
||conjugacy class|| || ||S4 := SymmetricGroup(4); _
AsList(ConjugacyClass(S4, (1,2,3)));|| ||
||conjugate group|| || ||ConjugateGroup(SymmetricGroup(4), (4, 5));|| ||
||conjugacy classes|| || ||ConjugacyClasses(SymmetricGroup(4));|| ||
||stabilizer|| || || || ||
||orbit|| || || || ||
||transitive test|| || || || ||
||~ ||~ ##EFEFEF|@@_______________________________________________________@@##||~ ##EFEFEF|@@_______________________________________________________@@##||~ ##EFEFEF|@@_______________________________________________________@@##||~ ##EFEFEF|@@_______________________________________________________@@##||


[[# grammar-invocation-note]]
+ [#grammar-invocation Grammar and Invocation]

[[# var-expr-note]]
+ [#var-expr Variables and Expressions]

[[# arithmetic-logic-note]]
+ [#arithmetic-logic Arithmetic and Logic]

[[# strings-note]]
+ [#strings Strings]

[[# arrays-note]]
+ [#arrays Arrays]

[[# sets-note]]
+ [#sets Sets]

[[# arith-seq-note]]
+ [#arith-seq Arithmetic Sequences]

[[# dictionaries-note]]
+ [#dictionaries Dictionaries]

[[# functions-note]]
+ [#functions Functions]

[[# execution-control-note]]
+ [#execution-control Execution Control]

[[# exceptions-note]]
+ [#exceptions Exceptions]

[[# streams-note]]
+ [#streams Streams]

[[# processes-env-note]]
+ [#processes-env Processes and Environment]

[[# libraries-namespaces-note]]
+ [#libraries-namespaces Libraries and Namespaces]

[[# reflection-note]]
+ [#reflection Reflection]

[[# vectors-note]]
+ [#vectors Vectors]

[[# matrices-note]]
+ [#matrices Matrices]

[[# combinatorics-note]]
+ [#combinatorics Combinatorics]

[[# factorial-note]]
++ [#factorial factorial]

//n!// is the product of the integers 1 through //n//.

//n!// is the number of permutations or bijections on a set of //n// elements.

[[# binomial-coefficient-note]]
++ [#binomial-coefficient binomial coefficient]

[[# multinomial-coefficient-note]]
++ [#multinomial-coefficient multinomial coefficient]

[[# int-partitions-note]]
++ [#int-partitions integer partitions]

The number of ways of writing a positive integer //n// as a sum of positive integers.

When counting integer partitions, //2 + 1// and //1 + 2// are not considered to be distinct ways of summing to 3.  In other words, one is counting the multisets which sum to //n//.

[[# set-partitions-note]]
++ [#set-partitions set partitions]

[[# permutations-k-disjoint-cycles-note]]
++ [#permutations-k-disjoint-cycles permutations with k disjoint cycles]

[[# fibonacci-num-note]]
++ [#fibonacci-num fibonacci number]

[[# bernoulli-num-note]]
++ [#bernoulli-num bernoulli number]

[[# catalan-num-note]]
++ [#catalan-num catalan number]

[[# number-theory-note]]
+ [#number-theory Number Theory]

[[# elliptic-curves-note]]
+ [#elliptic-curves Elliptic Curves]

[[# rational-algebraic-numbers-note]]
+ [#rational-algebraic-numbers Rational and Algebraic Numbers]

[[# polynomials-note]]
+ [#polynomials Polynomials]

[[# special-functions-note]]
+ [#special-functions Special Functions]

[[# permutations-note]]
+ [#permutations Permutations]

[[# groups-note]]
+ [#groups Groups]

A //group// is a set G and a binary operator—written here as{{*}}—which takes elements of the set as operands and obeys the following axioms:

* //Closure:// For every g and h in G, g * h is also in G.
* //Identity:// There exists e in G such that for all g in G, e * g = g * e = g.
* //Associativity:// For all f, g and h in G, (f * g) * h = f * (g * h).
* //Inverse:// For every g in G, there exists g' in G such that g * g' = g' * g = e.

//Abelian// groups obey an additional axiom:

* //Commutativity:// For all g and h in G, g * h = h * g.

The //order// of a group is the number elements in the set.  The smallest group is the //trivial group//, which contains a single element which is the identity.  It has order 1.

The integers, rationals, real numbers, and complex numbers are Abelian groups under addition; zero is the identity element.  The integers and rationals are countably infinite.  The real numbers and complex numbers are uncountably infinite.

The integers modulo //n// are an Abelian group under addition; zero is the identity number.  The group is finite and has order //n//.

The non-zero rationals, non-zero real numbers, and non-zero complex numbers are Abelian groups under multiplication; one is the identity element.

A permutation is a bijection on a set of //n// elements.  The permutations of size //n// form a group under composition; the group is non-Abelian when //n > 2//.  The identity permutation which maps each element of the set to itself is the group identity.  The order of the group is //n//!.

The classical Lie groups are examples of infinite, non-Abelian groups.  In all cases the group operation is matrix multiplication:

||GL(n, ℝ)||general linear group of degree n||invertible n×n matrices||
||SL(n, ℝ)||special linear group of degree n||n×n matrices with determinant one||
||O(n, ℝ)||orthogonal group of degree n||n×n orthogonal matrices; i.e. MM^^T^^ = I||
||SO(n, ℝ)||special orthogonal group of degree n||n×n orthogonal matrices with determinant one||
||U(n, ℂ)||unitary group of degree n||n×n unitary matrices; i.e. MM* = I||
||SU(n, ℂ)||special unitary group of degree n||n×n unitary matrices with determinant one||

[[# named-groups-note]]
++ [#named-groups named groups]

Some well-known groups can be specified by name.

The symmetric group S,,n,, is the group of permutations on a set of //n// elements.

The alternating group A,,n,, is the group of //even// permutations on a set of //n// elements.

The cyclic group Z/n is a group generated by a single element of order //n//.  It is Abelian group and is isomorphic to the integers modulo //n// under addition.

The dihedral group D,,n,, is the symmetry group of the regular n-polygon.

[[# group-by-order-note]]
++ [#group-by-order group by order]

[[# group-from-permutation-generators-note]]
++ [#group-from-permutation-generators group from permutation generators]

**gap:**

When a group is created using {{GroupByGenerators}}, the generators returned by {{GeneratorsOfGroup}} will not necessarily be the same as the generators provided to the constructor.

If the group is created using {{GroupWithGenerators}}, then the generators returned by {{GeneratorsOfGroup}} will be the same.

[[# direct-prod-note]]
++ [#direct-prod direct product]

The direct product is a group defined on the Cartesian product of two groups.

Given groups //G// and //H//, elements //g, g'// in //G//, and elements //h, h'// in //H//, the group operation is //(g, h) * (g', h') = (g * g', h * h')//.

[[# free-prod-note]]
++ [#free-prod free product]

A free product is group defined on equivalence classes of words consisting of elements from two groups //G// and //H//.

The equivalence relation is defined in terms of reductions.  Two adjacent elements in the word from the same group can be replaced by their product, and the identity element of either group can be removed.

The group operation is concatenation.

The free product is an infinite group when both groups are non-trivial.

**gap**

Some functions do not appear to work on free products: {{Order()}} and {{Random()}}.

[[# free-group-note]]
++ [#free-group free group]

[[# group-from-presentation-note]]
++ [#group-from-presentation-note group from presentation]

[[# all-group-elem-note]]
++ [#all-group-elem all elements]

How to iterate through all elements in a group.

[[# group-generators-note]]
++ [#group-generators generators]

[[# group-identity-elem-note]]
++ [#group-identity-elem identity element]

The group identity //e//.

For all //g// in //G//, //e * g = g * e = g//.

[[# random-group-elem-note]]
++ [#random-group-elem random element]

How to select an element from the group randomly.

[[# group-op-note]]
++ [#group-op group operation]

How 

[[# inverse-group-elem-note]]
++ [#inverse-group-elem inverse element]

Each element //g// in a group has an inverse //g^^-1^^// such that //g * g^^-1^^ = g^^-1^^ * g = e// where //e// is the identity element.

[[# commutator-note]]
++ [#commutator commutator]

[[# generator-word-for-elem-note]]
++ [#generator-word-for-elem generator word for element]

[[# elem-by-generator-word-len-note]]
++ [#elem-by-generator-word-len elements by generator word length]

[[# group-elem-order-note]]
++ [#group-elem-order element order]

For an element //g// in a finite group, there must be a positive integer //n// such that //g^^n^^// is the identity element.  The order of an element is the smallest such //n//.

[[# identify-group-note]]
++ [#identify-group identify group]

[[# group-to-presentation-note]]
++ [#group-to-presentation group to presentation]

Provide a presentation for the group.

[[# group-order-note]]
++ [#group-order group order]

How many elements are in the group.

[[# cyclic-test-note]]
++ [#cyclic-test cyclic test]

Is the group generated by single element.

[[# abelian-test-note]]
++ [#abelian-test abelian test]

Is the group operation commutative.

[[# subgroups-note]]
+ [#subgroups Subroups]

A //subgroup// is a subset of a group which is itself a group.

A nontrivial group always has at least two subgroups: the group itself and the trivial subgroup.  A proper subgroup is a subgroup which is not equal to the group itself.

One test whether a subset //H// of a group //G// is a subgroup is verify that //H// is nonempty and for every //x// and //y// in //H//, //xy^^-1^^// is in //H//.

//Lagrange's theorem and Sylow Theorems//

[[# all-subgroups-note]]
++ [#all-subgroups all subgroups]

A list of all subgroups in a group.

[[# subgroup-lattice-note]]
++ [#subgroup-lattice subgroup lattice]

The subgroups arranged by inclusion in a lattice.

[[# maximal-subgroups-note]]
++ [#maximal-subgroups maximal subgroups]

A maximal subgroup is a proper subgroup which is not contained in any other proper subgroup.

[[# frattini-subgroup-note]]
++ [#frattini-subgroup frattini subgroup]

The Frattini subgroup is the intersection of all maximal subgroups.

[[# subgroup-from-generators-note]]
++ [#subgroup-from-generators subgroup from generators]

**gap:**

{{ClosureGroup}} finds the smallest group containing a group and a list of elements, some of which might not be in the group which is the first argument.

[[# normal-subgroups-note]]
++ [#normal-subgroups normal subgroups]

The normal subgroups of a group.

A subgroup //H// of a group //G// is normal if its left and right cosets coincide.  That is //gH = Hg// for all //g// in //G//.  Another way to express this is that //H// is invariant under conjugation, or that //H = g^^-1^^Hg// for all //g// in //G//.

The significance of normal subgroups is that we can define a group operation on the cosets using representatives if and only if the subgroup is normal.

The first group isomorphism theorem states that the kernel of a group homomorphism is a normal subgroup.

For //n ≥ 5//, the only proper non-trivial normal subgroup of //S,,n,,// is //A,,n,,//.

[[# group-homomorphisms-note]]
+ [#group-homomorphisms Group Homomorphisms]

A //homomorphism// is a function φ from (G, *) to (H, *') such that

* φ(x * y) = φ(x) *' φ(y) for all x, y ∈ G.

An //isomorphism// is a bijective //homomorphism//.

If an isomorphism exists between two groups, they are said to be //isomorphic//.   Isomorphic groups are in a sense the same; group theory is the study of properties which are invariant under isomorphism.  Elsewhere we may speak of two isomorphic groups as being the same group.

[[# actions-note]]
+ [#actions Actions]

A group G is said to //act// on a set A if there is an operation ⋅: G × A → A such that

* g₁⋅(g₂⋅a) = (g₁*g₂)⋅a for all g₁, g₂ ∈ G and a ∈ A
* e⋅a = a for all a ∈ A where e is the identity in A

[[# pari-gp]]
+ [#top Pari/GP]

[https://pari.math.u-bordeaux.fr/pub/pari/manuals/2.9.0/tutorial.pdf A Tutorial for Pari/GP (pdf)]
[https://pari.math.u-bordeaux.fr/dochtml/html/ Pari/GP Functions by Category]
[http://www.staff.science.uu.nl/~beuke106/boek/refcard.pdf Pari/GP Reference Card (pdf)]

[[# magma]]
+ [#top Magma]

[http://magma.maths.usyd.edu.au/calc/ Online Calculator]
[http://magma.maths.usyd.edu.au/magma/handbook/ Handbook]

[[# gap]]
+ [#top GAP]

[http://www.gap-system.org/Manuals/doc/ref/chap0.html GAP - Reference Manual]

[[# singular]]
+ [#top Singular]

[http://www.singular.uni-kl.de/Manual/latest/index.htm Singular Manual]