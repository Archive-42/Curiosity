{
  "data": {
    "markdownRemark": {
      "html": "<h1>Transitors:</h1>\n<p>Basic element of computation that controls the flow of electricity, similar to but different than a switch. Transitors are used to build logic gates.</p>\n<h4>Logic gate:</h4>\n<p>A collection of transistors put together to perform one of the basic boolean logic functions on a single bit or a collection of bits. (E.g., AND, NOT, XOR, OR, NAND, NOR)</p>\n<p>NAND gate is made of two transistors.<br>\nNAND and NOR gates are called functionally complete since they can each be used to build any other gates.</p>\n<p>If you can make a NAND gate, you can make an entire computer.</p>\n<h4>Flip flop:</h4>\n<p>Basic memory storage device that can be used to hold registers - main memory is rarely made up of flip flops.</p>\n<h4>AND Gate:</h4>\n<p>It has two inputs (can have more than two) and it has an output.</p>\n<p>A with a 1 on it, B with a 1 on it, want output to have 1 on it.</p>\n<h4>Boolean Logic:</h4>\n<p>If condition A is true &#x26;&#x26; condition B is true...\nIf condition A || condition B is true...</p>\n<p>Basic boolean operations are often demonstrated with truth tables.\nValues on left are input, values on left are result:</p>\n<h4>Truth table for NOT:</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">NOT Gate\n---------\nA    Not A\n0    1\n1    0</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Truth table for other operations are similar but have two inputs:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">A|B|A AND B|A OR B|A XOR B|A NOR B|A NAND B\n0|0|   0   |  0       0   |   1   |   1\n0|1|   0   |  1       1   |   0   |   1\n1|0|   0   |  1       1   |   0   |   1\n1|1|   1   |  1       0   |   0   |   0</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Javascript Bitwise operators are numeric, not logical, so don't mix and match with boolean or you might get weird results.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">  128 64 32 16  8 4 2 1\n    0  0  0  0  1 1 0 0 = 8 + 4 = 12\n|   0  1  1  0  0 1 1 1 = 64 + 32 + 4 + 2 + 1 = 103\n    0  1  1  0  1 1 1 1 = 64 + 32 + 8 + 4 + 2 + 1 = 111</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">     128 64 32 16 8 4 2 1\n     1    1  0  1 0 1 1 0 = 128 + 64 + 16 + 4 + 2 = 214\nAND  1    1  1  1 0 0 0 0 = 128 + 64 + 32 + 16 = 240\n     1    1  0  1 0 0 0 0 = 128 + 64 + 16 = 208</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>If you want to extract two bits, you can shift a number</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Original number: 01101111\nShifted one to the right: 001101111 &lt;-- last one will fall off into space\nShifted two to the right: 00011011\nShifted three to the right: 00001101\nShifted four to the right: 00000110\nShifted five to the right: 00000011\nShifted six to the right: 00000001</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">     00000001 = b\n&amp;    00000011 - and mask\n-------------\n     00000001\n\na = 0b01101111;\nb = a &gt;&gt; 6;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>Architecture:</h2>\n<p>Visual 6502 : Can see what parts of memory are being accessed during program execution.</p>\n<h3>While program running:</h3>\n<p>Has to go out to RAM to see what the next instruction is.\nHow is a number a computer instruction?\nRegister - program counter: holds the index into memory of where the next instruction is, will store it in the instruction manager (IR).</p>\n<p>In our simulation, 8 bits, each bit has a meaning. Some of the bits get stripped off and go to the control unit, some get stripped and sent to register file, and some go to the ALU.</p>\n<p>Register file - R0 to R7 (all CPUs have different register names, this is a common one) - registers are like variables. R0 to R7, that's not many variables. Within the CPU, extremely fast to operate on.</p>\n<p>When a compiler builds code to run on the CPU, tries to use registers as much as possible to keep the speed high.</p>\n<h3>ALU - arithmetic logic unit:</h3>\n<p>Responsible for arithmetic and bitwise operations, and comparisons between numbers.</p>\n<h3>Cache:</h3>\n<p>High speed memory that's close to the CPU. If reading byte at address 10, likely to get address 11, so cache stores subsequent bytes when retrieving data from RAM.</p>\n<h3>Memory Address Register:</h3>\n<p>Address of memory we're interested in reading or writing.\nMemory Data Register: In case of write, holds value of what we want to write. In the case of a read, MDR gets loaded with the value that is in memory at the Memory Address Register address.</p>\n<p>In our emulator, you'll see this in the emulator.js file</p>\n<h3>Interrupt Handler:</h3>\n<p>If key gets hit, raises a voltage on a wire, which goes to the interrupt handler which sets a value in the interrrupt status register and the CPU sees it. When it goes to execute the next instruction, a complicated set of steps happen where it finds another location in memory to begin executing instructions. That other location will handle the interrupt handler program. Interrupt handler returns and code continues executing like it did before the interrupt occurred.</p>\n<ul>\n<li>Interrupt flow of execution, perform some action in the handler, and then resume the flow of execution where the interrupt left off.</li>\n</ul>\n<p>Can decide which interrupts you're interested in by using the interrupt mask register - gets bitwise ANDed with the status register and masks out interrupts you're not interested in.</p>\n<p>Our CPU has two interrupts defined: a timer interrupt that occurs once per second, and a keyboard interrupt when a key is pressed.\nBy setting interrupt register mask to all 0, masks them out so you don't get any interrupts.</p>\n<p>One of the problems with having the CPU be the sole control of the RAM, the CPU will be busy copying data into RAM from devices that have a lot of data to present to it.</p>\n<p>For example, if you have a disk and the OS wants to read block 7004 on the disk, the OS is going to command the peripheral to read block 7004 and get back to it when it's done. How will CPU know it's finished? Will get an interrupt.</p>\n<p>Direct memory access - disk is asked to read a block, it puts it into memory and when it's loaded, an interrupt happens to let the CPU know the information is there.</p>\n<p>When we write the emulator, we'll have registers, an ALU, a PC to keep track of what instruction we're doing, an instruction register, simulated RAM that allows you to read and write bytes from RAM.</p>\n<h3>Important to remember: Individual instructions don't do very much.</h3>\n<h4>ADD:</h4>\n<p>Adds two numbers.</p>\n<h4>COMPARE:</h4>\n<p>Compares two numbers and sets flags whether numbers are greater than, equal or less than each other.</p>\n<h4>JUMP:</h4>\n<p>Takes program counter from where it's running, jumps to another address and continues running there.\nIndividual handlers we write in our emulator to simulate the individual instructions are short, usually one-liners.</p>\n<p>Complexity of how to make a CPU work is from building on these tiny instructions. Doing that is a pain, which is why nobody programs that way.</p>\n<p>Machine code - usually if you write in machine code, hexadecimal.</p>\n<p>Mneumonics are great - three or four letter code lets you know what you're doing (easier than remembering a hexadecimal number).</p>\n<p>Talking about CPU and assembly language is down to the metal.</p>\n<h3>Clock:</h3>\n<p>Driver of voltage that goes up and down several times a second - every time it raises or lowers, work gets done. A lot of instructions just take one clock to execute. You can execute billions of instructions per second on a modern CPU.</p>\n<h3>Operations or Opcodes:</h3>\n<p>Opcode is shorthand for the instruction that you're executing - not the data it's working on. ADD Register 0 to Register 4 - Opcode is AND. Register 0 and Register 4 are operands.</p>\n<h3>Bus:</h3>\n<p>A way for information to get from one part of the motherboard to another part of the motherboard. It's like a telephone line (bunch of wires). Different buses on the system that get used to move information back and forth.</p>\n<h3>RAM:</h3>\n<p>Grid of bits - more commonly exposed to programmers at machine level and up as an array of bytes. Program counter will be an index into the array of bytes.</p>",
      "frontmatter": {
        "date": "2018-08-19",
        "title": "Introduction to Computer Architecture",
        "chapter": null,
        "subtitle": null,
        "tags": ["computer architecture"],
        "path": "/Intro-to-Computer-Architecture"
      }
    }
  },
  "pageContext": {
    "isCreatedByStatefulCreatePages": false,
    "pathSlug": "/Intro-to-Computer-Architecture",
    "prev": {
      "frontmatter": {
        "path": "/Binary-Conversion",
        "title": "Binary Conversion",
        "tags": ["binary conversion"],
        "subtitle": null,
        "chapter": null
      }
    },
    "next": {
      "frontmatter": {
        "path": "/Computer-Architecture-Subroutines",
        "title": "Computer Architecture: Subroutines",
        "tags": ["computer architecture", "subroutines"],
        "subtitle": null,
        "chapter": null
      }
    }
  }
}
