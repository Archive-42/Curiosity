{
  "data": {
    "markdownRemark": {
      "html": "<h3>Data structures are like cookware:</h3>\n<p>The tools you use to accomplish your task\nAlgorithms are the recipe:\nThe set of instructions you follow.\nWill specify what data structure to use</p>\n<p>There are niche data structures that most developers could never use\nOnce you get into specialized applications, they can be handy</p>\n<h3>Terminology:</h3>\n<p>Arrays => lists\nObjects => dictionaries</p>\n<p>Objects and lists can get you very far\nNot optimized for any one task</p>\n<h3>List</h3>\n<p>A list is a contiguous block in memory where you store your list of things\nPredefined amount of space\nCan add/remove because they’ve added that functionality\nCanonically with an array/list, it is a static amount of size\nIn JS and Python, if you start off with a list, it’s extra work to add to it because you have to expand the space in the list to accommodate additional data</p>\n<p>For the purposes of what we’re talking about today, assume a list/array is only a predefined amount of space</p>\n<h3>Linked Lists</h3>\n<p>Linked List represents a list in a different way:</p>\n<ul>\n<li>Stores each value into a node</li>\n<li>Stores also a pointer to the next node in the list</li>\n</ul>\n<p>With an array/list, you have a predefined amount of space and if you want to add to it later on, more work to expand the amount of space available to the list/array</p>\n<p>Linked List inverts that - is constructed in terms of the individual elements</p>\n<ul>\n<li>Each element is encapsulated in its own node and then the list itself is constructed with pointer arrows\n<code class=\"language-text\">1-&gt;2-&gt;B-&gt;4-&gt;5-&gt;null</code>\n1 knows about 2 knows about B knows about 4 knows about 5 knows about null</li>\n</ul>\n<p>If you have an array/list and say it’s 10 spots, it will take up 10 spots in memory even when empty\nEmpty linked list takes up no memory</p>\n<p>Node is a dictionary/object/class that holds a value and a next</p>\n<p>Linked List class - head and tail\n<code class=\"language-text\">1-&gt;2-&gt;3-&gt;N</code>\nHead - first node in the list\nTail - last node in the list</p>\n<ul>\n<li>Linked List knows about the first node in the list and last node in the list (1 and 3)</li>\n<li>def contains(target_value) -> checks to see if linked list contains the value you’re looking for</li>\n<li>def get_max should return maximum value and keep track of current maximum value</li>\n</ul>\n<h3>Queue data structure:</h3>\n<ul>\n<li>\n<p>Can recreate using a list or array</p>\n</li>\n<li>\n<p>Encapsulates the functionality you get when you end up in a line</p>\n</li>\n<li>\n<p>When you join, you’re at the back</p>\n</li>\n<li>\n<p>When you leave, you’re at the front</p>\n</li>\n<li>\n<p>Stay for duration of the line</p>\n</li>\n<li>\n<p>First in first out</p>\n</li>\n<li>\n<p>Enqueue - add to the end</p>\n</li>\n<li>\n<p>Dequeue - remove from front</p>\n</li>\n<li>\n<p>lens - length of the list</p>\n</li>\n<li>\n<p>Catch - will use linked list that you made in order to implement the queue</p>\n</li>\n<li>\n<p>self.storage = LinkedList()</p>\n</li>\n<li>\n<p>Adding and removing from linked list</p>\n</li>\n<li>\n<p>5->N</p>\n</li>\n<li>\n<p>H->T</p>\n</li>\n<li>\n<p>Remove H</p>\n</li>\n</ul>\n<h3>Stack data structure</h3>\n<p>Last in first out</p>\n<h3>Binary Search Trees:</h3>\n<p>Tree is like a linked list\nWith node you can have multiple pointers\nBinary is enforcing that there is only max two children from any one node\n<code class=\"language-text\">Left &lt; parent &lt;= right</code>\nIf adding input, need to put into node and compare to root of tree\nIf already has a node on the side the new node would fit, keep traversing that side of the tree until there is space for it</p>\n<p>contains - if a value exists in the binary search tree\nget_max - maximum value of the binary search tree</p>\n<h3>Heap data structure:</h3>\n<p>How do we design a data structure to get max value ASAP\nWe’ll be implementing max heap</p>\n<p>Fastest way to access something in an array - index\nHeap tries to take advantage of that\nTop of the heap is always the max (in max heap)\nNot binary search tree because not the same rules\nMultiple ways to represent heap\nMakes more sense to implement it as a binary tree, but sometimes makes more sense to implement as array</p>\n<h3>Heap as tree:</h3>\n<p>insert 101</p>\n<ul>\n<li>By end, 101 should be at top</li>\n<li>Will be added at the bottom layer</li>\n<li>Will see that parent is less, will swap with parent (using bubble_up)</li>\n<li>3 and 101 will swap</li>\n<li>19 and 101 will swap</li>\n<li>100 and 101 will swap</li>\n<li>delete will remove top of heap</li>\n<li>Remove 100</li>\n<li>Take last element in heap (this case 7)</li>\n<li>Put that at top</li>\n<li>Compare with two children and swap with highest (swaps with 36)</li>\n<li>Compares with children (25 and 1), swaps with highest (25)</li>\n<li>get_max will be easiest</li>\n<li>_bubble_up : helper method</li>\n<li>_sift_down: helper method</li>\n</ul>\n<p>Like binary search trees, there are rules for how heaps are laid out\nDirect children have to be less than parents</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">[0, 100, 19, 36, 17, 12, 25, 5, 9, 15, 6, 11, 13, 8, 1, 4]\nnode = i\nleft = 2i\nright = 2i + 1\nchild to parent = floor(i/2)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Heap as array:</h3>\n<p>No nodes in heap, just an array with values\nTree was because intuitive to talk about heaps in that case\nArray integer</p>\n<h3>Advice:</h3>\n<p>Draw everything out with different inputs to see how things will work</p>",
      "frontmatter": {
        "date": "2018-07-16",
        "title": "CS10: Data Structures & Algorithms",
        "chapter": null,
        "subtitle": "Day One",
        "tags": ["data structures", "algorithms", "CS10"],
        "path": "/CS10-Data-Structures-And-Algorithms-Day-One"
      }
    }
  },
  "pageContext": {
    "isCreatedByStatefulCreatePages": false,
    "pathSlug": "/CS10-Data-Structures-And-Algorithms-Day-One",
    "prev": {
      "frontmatter": {
        "path": "/DevOps-Deployment-Mini-Sprint",
        "title": "DevOps:",
        "tags": ["DevOps"],
        "subtitle": "Deployment Mini Sprint",
        "chapter": null
      }
    },
    "next": {
      "frontmatter": {
        "path": "/Overview-of-Algorithmic-Techniques",
        "title": "Lambda School: Overview of Algorithmic Techniques",
        "tags": ["algorithms"],
        "subtitle": null,
        "chapter": null
      }
    }
  }
}
