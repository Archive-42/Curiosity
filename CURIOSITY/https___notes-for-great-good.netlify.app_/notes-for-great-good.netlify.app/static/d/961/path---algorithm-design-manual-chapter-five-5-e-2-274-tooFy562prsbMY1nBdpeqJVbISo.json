{
  "data": {
    "markdownRemark": {
      "html": "<p>A graph <em>G</em> = <em>(V, E)</em> consists of vertex <em>V</em> together with a set of <em>E</em> of vertex pairs or edges. The key to using using graph algorithms effectively is modeling your problem to take advantage of existing algorithms. First step in any graph problem is figuring out what type of graph you are dealing with:</p>\n<ul>\n<li>\n<p><em>Undirected</em> vs <em>directed</em>: A graph is undirected if the edges are present in both directions -> any path has paths going from <em>A</em> to <em>B</em> and from <em>B</em> to <em>A</em>, etc.</p>\n</li>\n<li>\n<p><em>Weighted</em> vs <em>unweighted</em>: Each edge in a weighted graph is assigned a numerical value (weight)</p>\n</li>\n<li>\n<p><em>Simple</em> vs <em>non-simple</em>: Some types of edges complicate working with graphs and graphs that do not have these types of edges are considered simple. Examples of complicated edges are self-loops where an edge involves only one vertex and multi-edge edges which occur more than once in a graph.</p>\n</li>\n<li>\n<p><em>Sparse</em> vs <em>dense</em>: Graphs are considered sparse when only a small fraction of possible vertex pairs have edges between them and dense if a large fraction do.</p>\n</li>\n<li>\n<p><em>Cyclic</em> vs <em>acyclic</em>: Acyclic graphs are those without cycles. Trees are an example of connected, acyclic graphs. Directed Acyclic Graphs (DAGs) arise naturally in scheduling problems where a directed edge (x, y) indicates that activity <em>x</em> must occur before <em>y</em>. Topological sorting orders the vertices of a DAG to respect precedence constraints.</p>\n</li>\n<li>\n<p><em>Embedded</em> vs <em>topological</em>: A graph is embedded if the vertices and edges are assigned geometric positions - any drawing of a grpah is an embedding. Underlying topology is the complete graph connecting each part of vertices.</p>\n</li>\n<li>\n<p><em>Implicit</em> vs <em>Explicit</em>: Some graphs are not constructed and traversed, but built as we use them. An example of this is backtrack search. The vertices of these implicit search graphs are the states of the search vector while edges link pairs of states that can be directly generated from each other. Because you don't have to store the entire graph, often easier to work with an implicit graph.</p>\n</li>\n<li>\n<p><em>Labeled</em> vs <em>unlabeled</em>: Each vertex is assigned a name or identifier in a labeled graph to distinguish it from other vertices. A common problem is isomorphism testing - determining whether the topological structure of two graphs are identical if labels are ignored. Such problems usually solved using backtracking to assign each vertex in each graph a label such that the structures are identical.</p>\n</li>\n</ul>\n<h3>Friendship Graph - Social network</h3>\n<ul>\n<li><em>If I am your friend, are you my friend?</em> - Asking if the graph is directed or undirected</li>\n<li><em>How close a friend are you?</em> - This could add weight to a graph</li>\n<li><em>Am I my own friend?</em> - Addresses whether graph is simple</li>\n<li><em>Who has the most friends?</em> - Degree of a vertex is the number of edges adjacent to it. The most popular person defines the vertex of highest degree in the friendship graph</li>\n<li><em>Do my friends live near me?</em> - Many of your friends are friends based on geography. A full understanding of social networks requires an embedded graph where each vertex is associated with a point where they live</li>\n<li><em>Oh, you also know her?</em> - Social networking sites are based on explicitly defining links between people, but a complete friendship graph of the world is represented implicitly - each person knows who their friends are but not who their friends are friends with without directly asking.</li>\n<li><em>Are you truly an individual or just one of the faceless crowd?</em> - Whether the graph is labeled or unlabeled</li>\n</ul>\n<h3>Take Home:</h3>\n<p>Graphs can be used to model a wide variety of structures and relationships. Graph theoretic terminology gives us a language to talk about them.</p>\n<h3>Data Structures for Graphs</h3>\n<p>Selecting the right graph data structure can have an enormous impact on performance.</p>\n<ul>\n<li><em>Adjacency Matrix</em> - Edges[i, j] = 1 if edge of graph, 0 if not. May use excessive space if many vertices and few edges.</li>\n<li><em>Adjacency List</em> - Use linked lists to store neighbors adjacent to each vertex</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Comparison</th>\n<th>Winner</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Faster to test if (x, y) in graph?</td>\n<td>Adjacency matrixes</td>\n</tr>\n<tr>\n<td>Faster to find the degree of a vertex?</td>\n<td>Adjacency lists</td>\n</tr>\n<tr>\n<td>Less memory on small graphs?</td>\n<td>Adjacency lists (m + n) vs (n<sup>2</sup>)</td>\n</tr>\n<tr>\n<td>Less memory on big graphs?</td>\n<td>Adjacency matrixes (small win)</td>\n</tr>\n<tr>\n<td>Edge insertion or deletion?</td>\n<td>Adjacency matrices O(1) vs O(d)</td>\n</tr>\n<tr>\n<td>Faster to traverse the graph?</td>\n<td>Adjacency list O(m + n) vs O(n<sup>2</sup>)</td>\n</tr>\n<tr>\n<td>Better for most problems?</td>\n<td>Adjacency lists</td>\n</tr>\n</tbody>\n</table>\n<h3>Take Home:</h3>\n<p>Adjacency lists are the right data structure for most applications of graphs.</p>\n<p>We represent a graph using following data type. For each graph, we keep a count of number of vertices and assign each vertex a unique ID from 1 to <em>n</em> vertices. Represent edges with linked lists.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> MAXV    1000 </span><span class=\"token comment\">/* max number of vertices */</span>\n\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* adjacency info */</span>\n    <span class=\"token keyword\">int</span> weight<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* edge weight, if any */</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">edgenode</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* next edge in list */</span>\n<span class=\"token punctuation\">}</span> edgenode<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    edgenode <span class=\"token operator\">*</span>edges<span class=\"token punctuation\">[</span>MAXV <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* adjacency info */</span>\n    <span class=\"token keyword\">int</span> degree<span class=\"token punctuation\">[</span>MAXV <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* outdegree of each vertex */</span>\n    <span class=\"token keyword\">int</span> nvertices<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of vertices in graph */</span>\n    <span class=\"token keyword\">int</span> nedges<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of edges in graph */</span>\n    bool directed<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* is the graph directed? */</span>\n<span class=\"token punctuation\">}</span> graph<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Degree field counts the number of meaningful entries for a given vertex.</p>\n<p>A typical graph format consists of an initial line with the number of vertices and edges in the graph followed by a listing of the edges at one vertex pair per line.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">initialize_graph</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> bool directed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    g<span class=\"token operator\">-></span>nvertices <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    g<span class=\"token operator\">-></span>nedges <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    g<span class=\"token operator\">-></span>directed <span class=\"token operator\">=</span> directed<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> MAXV<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> g<span class=\"token operator\">-></span>degree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> MAXV<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> g<span class=\"token operator\">-></span>edges<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Reading the graph means inserting each edge into the structure.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">read_graph</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> bool directed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* number of edges */</span>\n    <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* vertices in edge (x, y) */</span>\n    <span class=\"token function\">initialize_graph</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> directed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d %d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d %d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">insert_edge</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> directed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The critical routine is insert_edge. New edgenodes are inserted at the beginning of adjacency list. We pass boolean flag to determine whether to insert two copies of each node or one.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">insert_edge</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">,</span> bool directed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    edgenode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* temporary pointer */</span>\n    p <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>edgenode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* allocate edgenode storage */</span>\n    p<span class=\"token operator\">-></span>weight <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    p<span class=\"token operator\">-></span>y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n    p<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> g<span class=\"token operator\">-></span>edges<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    g<span class=\"token operator\">-></span>edges<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n    g<span class=\"token operator\">-></span>degree<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>directed <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">insert_edge</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> True<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        g<span class=\"token operator\">-></span>nedges<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Printing is just a matter of two nested loops - one to go through vertices and one to go through adjacent edges.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">print_graph</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    edgenode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* temporary pointer */</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d: \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        p <span class=\"token operator\">=</span> g<span class=\"token operator\">-></span>edges<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" %d\"</span><span class=\"token punctuation\">,</span> p<span class=\"token operator\">-></span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            p <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Traversing a Graph</h3>\n<p>Each vertex exists in one of three states:</p>\n<ul>\n<li><em>undiscovered</em> - vertex in original state</li>\n<li><em>discovered</em> - vertex found, but all edges have yet to be checked</li>\n<li><em>processed</em> - vertex after all edges have been visited</li>\n</ul>\n<p>Start at one vertex, which is now considered discoverred but not yet processed. Explore all edges leaving that vertex. If the edge leads to an undiscovered vertex, it becomes marked as discovered and added to the list of vertices to process. If the edge leads to a processed vertex or an already discovered vertex, it is ignored.</p>\n<p>Every undirected edge will be looked at twice - one for each endpoint - while directed edges will get assessed once.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">bool processed<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* which vertices have been processed */</span>\nbool discovered<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* which vertices have been discovered */</span>\n<span class=\"token keyword\">int</span> parent<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* discovery relation */</span>\n    <span class=\"token comment\">/* Each vertex is initialized as undiscovered: */</span>\n<span class=\"token function\">initialize_search</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        processed<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> discovered<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> False<span class=\"token punctuation\">;</span>\n        parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Once vertex discovered, added to a queue. Since we process vertices FIFO, oldes vertices are expanded first, which are closest to the root.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    queue q<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* queue of vertices to visit */</span>\n    <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* current vertex */</span>\n    <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* successor index */</span>\n    edgenode <span class=\"token operator\">*</span>p <span class=\"token comment\">/* temporary pointer */</span>\n    <span class=\"token function\">init_queue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    discovered<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">empty_queue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        v <span class=\"token operator\">=</span> <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">process_vertex_early</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        processed<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token punctuation\">;</span>\n        p <span class=\"token operator\">=</span> g<span class=\"token operator\">-></span>edges<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            y <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>y<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>processed<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> g<span class=\"token operator\">-></span>directed<span class=\"token punctuation\">)</span>\n                <span class=\"token function\">process_edge</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>discovered<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>q<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                discovered<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> True<span class=\"token punctuation\">;</span>\n                parent<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            p <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">process_vertex_late</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>process<em>vertex</em>late, process<em>vertex</em>early, and process_edge allow us to customize traversal of the graph.</p>\n<p>Initially, we'll do all vertex processing on entry, so process<em>vertex</em>late() returns without action:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">process_vertex_late</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token function\">process_vertex_early</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Processed vertex %d\\n\"</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">process_edge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Processed edge (%d, %d)\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We print each vertex and edge exactly once.</p>\n<p>If we instead set process_edge to:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">process_edge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    nedges <span class=\"token operator\">=</span> nedges <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>we get an accurate count of the number of edges.</p>\n<h3>Finding Paths</h3>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">find_path</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> parents <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">==</span> end<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n%d\"</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">find_path</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> parents<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> parents<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" %d\"</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The tree constructed from breadth-first-search discovers vertices in order of increasing distance from root and so can be used to get the shortest path. The shortest path tree is only useful if breadth-first search was performed with one of the vertices you're interested in computing a path from used as root. It is also important to note that it only gives the shortest path if the graph is unweighted.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">connected_components</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* component number */</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token function\">initialize_search</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    c <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>discovered<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            c <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Component %d: \"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">process_vertex_early</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" %d\"</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h3>Two-Coloring Graphs</h3>\n<p>Seeks to assign a label (or color) to each vertex of a graph such that no edge links any two vertices of the same color. You could avoid conflicts by assigning every vertex a unique color, but the goal is to use as few colors as possible. Vertex coloring problems often arise in scheduling applications such as register allocation in compilers.</p>\n<p>A graph is bipartite if it can be colored without conflict using only two colors.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">twocolor</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span><span class=\"token punctuation\">(</span>g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        color<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> uncolored<span class=\"token punctuation\">;</span>\n    bipartite <span class=\"token operator\">=</span> True<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">initialize_search</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span><span class=\"token punctuation\">(</span>g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>discovered<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            color<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> white<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">process_edge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> it y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> color<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    bipartite <span class=\"token operator\">=</span> False<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Warning: not bipartite due to (\"</span><span class=\"token operator\">%</span>d<span class=\"token punctuation\">,</span> <span class=\"token operator\">%</span>d<span class=\"token punctuation\">)</span>\\n\"<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    color<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">complement</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">complement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> color<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>color <span class=\"token operator\">==</span> white<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> black<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>color <span class=\"token operator\">==</span> black<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> white<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Take Home Lesson</h3>\n<p>Breadth-first and depth-first searches provide mechanisms to visit each edge and vertex of the graph. They prove the basis of most simple, efficient graph algorithms.</p>\n<h3>Depth-First Search</h3>\n<p>Difference between depth and breadth-first search is the order in which vertices are explored. This order is dependent on the container in which the <em>discovered</em> vertices are stored.</p>\n<ul>\n<li>Queue: With first in, first out, we explore the oldest unexplored vertices first. Explorations radiate slowly from the starting vertex, defining a breadth-first search.</li>\n<li>Stack: By storing vertices last in, first out, we visit neighbors if they are available and back up only when surrounded by previously discovered vertices. Our explorations quickly move away from the starting point and define a depth-first search.</li>\n</ul>\n<p>Our implementation of dfs maintains a notion of time for each vertex. Time clock ticks each time we enter or exit any vertex. We then keep track of the entry and exit times for each vertex. Depth first search has a neat recursive implementation which eliminates the need to explicitly use a stack:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">DFS</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">)</span>\n    state<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"undiscovered\"</span>\n    process vertex u <span class=\"token keyword\">if</span> desired\n    time <span class=\"token operator\">=</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    entry<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> time\n    <span class=\"token keyword\">for</span> each v ∈ Adj<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token keyword\">do</span>\n        process edge <span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> desired\n        <span class=\"token keyword\">if</span> state<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"undiscovered\"</span> then\n            p<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> u\n            <span class=\"token function\">DFS</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">)</span>\n    state<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"processed\"</span>\n    exit<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> time\n    time <span class=\"token operator\">=</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The time intervals have interesting useful properties:</p>\n<ul>\n<li><em>Who is an ancestor?</em>: If <em>x</em> is the ancestor of <em>y</em> in a DFS tree, <em>x</em> has to be entered before <em>y</em> and <em>y</em> must be exited before <em>x</em>.</li>\n<li><em>How many descendants?</em> : The clock gets incremented in each vertex entry and vertex exit. So half the time difference between entry and exit times of <em>v</em> is the total descendants of <em>v</em>.</li>\n</ul>\n<p>Depth first search partitions edges of an undirected graph into two classes - tree edges (those that discover new vertices) and back edges (those whose other endpoint is an ancestor of the vertex being expanded).</p>\n<p>A depth first search can be thought of as a bread-first search with a stack instead of a queue.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    edgenode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* temporary pointer */</span>\n    <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* successor vertex */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>finished<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* allow for search termination */</span>\n    discovered<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n    time <span class=\"token operator\">=</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    entry_time<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> time<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">process_vertex_early</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    p <span class=\"token operator\">=</span> g<span class=\"token operator\">-></span>edges<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        y <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>y<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>discovered<span class=\"token punctuation\">[</span>u<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            parent<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">process_edge</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>processed<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token operator\">!</span> <span class=\"token operator\">=</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>g<span class=\"token operator\">-></span>directed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">process_edge</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>finished<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            p <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">process_vertex_late</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    time <span class=\"token operator\">=</span> time <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    exit_time<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> time<span class=\"token punctuation\">;</span>\n    processed<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Take Home:</h3>\n<p>DFS organizes vertices by entry/exit times and edges into tree and back edges. The organization is what gives DFS its real power.</p>\n<h3>Finding Cycles:</h3>\n<p>Back edges are key in finding cycles in undirected graphs. If there is no back edge, all edges are tree edges and no cycle exists in the tree. Any back edge going from <em>x</em> to ancestor <em>y</em> creates a cycle with tree path from <em>y</em> to <em>x</em>. These cycles are easy to find with DFS:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">process_edge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>discovered<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* found back edge */</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cycle from %d to %d: \"</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">find_path</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        finished <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The correctness of the cycle relies on processing each undiscovered edge once, which is why we use the finished flag to terminate after finding the first cycle.</p>\n<p>A vertex whose deletion disconnects a connected component of a graph is a <em>articulation vertex</em> or <em>cut-node</em>. Any graph with a cut-node is inherently fragile. The connectivity of a graph is the smallest number of vertices whose deletion will disconnect the graph. The connectivity is one if there is an articulation vertex.</p>\n<p>Back edges act like security cables, ensuring none of the vertices between the vertices it connects can be articulation vertices.</p>\n<p>Let reachable<em>answer[v] denote earliest reachable ancestor of vertex _v</em> from an ancestor of <em>v</em> using a back edge. Initially reachable_ancestor[v] = v;</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> reachable_ancestor<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* earliest reachable ancestor of v */</span>\n<span class=\"token keyword\">int</span> tree_out_degree<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* dfs tree outdegree */</span>\n<span class=\"token function\">process_vertex_early</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    reachable_ancestor<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>We update reachable<em>ancestor[v] when we ssee a back edge that takes us to an earlier ancestor than we've previously seen. Relative age can be determined from entry</em>times.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">process_edge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> class<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* edge class */</span>\n    class <span class=\"token operator\">=</span> <span class=\"token function\">edge_classification</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>class <span class=\"token operator\">==</span> TREE<span class=\"token punctuation\">)</span>\n        tree_out_degree<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tree_out_degree<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>class <span class=\"token operator\">==</span> BACK<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>entry_time<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> entry_time<span class=\"token punctuation\">[</span> reachable_ancestor<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            reachable_ancestor<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>Three cases of articulation vertices</strong>:</p>\n<ul>\n<li>Root cut-nodes - If the root has 2 or more children, it must be an articulation vertex. No edges from the subtree of the second child can possibly connect to the subtree of the first child.</li>\n<li>Bridge cut-nodes - if earlies reachable vertex from <em>v</em> is <em>v</em>, deleting the single edge (parent[v], v) disconnects the graph. Clearly, parent[v] must be an articulation vertex. Vertex <em>v</em> is also, unless it is a leaf.</li>\n<li>Parent cut-nodes - if the earlies reachable vertex from <em>v</em> is the parent of <em>v</em>, deleting the parent must sever <em>v</em> from the tree unless the parent is the root.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">process_vertex_late</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    bool root<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* is the vertex the root of the DFS tree? */</span>\n    <span class=\"token keyword\">int</span> time_v<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* earliest reachable time for v */</span>\n    <span class=\"token keyword\">int</span> time_parent<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* earliest reachable time for parent[v] */</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* test if v is the root */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree_out_degree<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Root articulation vertex: %d\\n\"</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    root <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* test if parent[v] is root */</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>reachable_ancestor<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">pritnf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Parent articulation vertex: %d\\n\"</span><span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>reachable_ancestor<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Bridge articulation vertex: %d\\n\"</span><span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tree_out_degree<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">/* test if v is not a leaf */</span>\n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Bridge articulation vertex: %d\\n\"</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        time_v <span class=\"token operator\">=</span> entry_time<span class=\"token punctuation\">[</span>reachable_ancestor<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        time_parent <span class=\"token operator\">=</span> entry_time<span class=\"token punctuation\">[</span>reachable_ancestor<span class=\"token punctuation\">[</span>parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>time_v <span class=\"token operator\">&lt;</span> time_parent<span class=\"token punctuation\">)</span>\n            reachable_ancestor<span class=\"token punctuation\">[</span>parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> reachable_ancestor<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>A signle edge whose deletion disconnects the graph is called a bridge. A graph without a bridge is edge-biconnected.</p>\n<p>Edge(x, y) is a bridge if it is a tree edge and no back edge connects from <em>y</em> or below to <em>x</em> or above.</p>\n<p>For directed graphs, the correct labeling of each edge can be determined from the state, discovery time, and parent of each vertex.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">edge_classification</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> x<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> true<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>discovery<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>processed<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> BACK<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>processed<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>entry_time<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> entry_time<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> FORWARD<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>processed<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>entry_time<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> entry_time<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> CROSS<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Warning, unclassified edge (%d, %d)\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Topological Sorting</h3>\n<p>Topological sorting is the most important operation on directed acyclic graphs and it orders the vertices on a line from left to right. This ordering can't exist if the graph contains a directed cycle.</p>\n<p>Topological sorting can be efficiently performed using depth-first searching. Labeling the vertices in the reverse order they were marked processed finds a topological sort of a DAG.</p>\n<p>Consider what happens to each directed edge {x, y} as we encounter it exploring <em>x</em>:</p>\n<ul>\n<li>\n<p>if <em>y</em> is undiscovered, we start a DFS of <em>y</em> before continuing with <em>x</em>. Y must be marked processed before <em>x</em> and <em>x</em> appears before <em>y</em> in topological order, as a must.</p>\n</li>\n<li>\n<p>if <em>y</em> is discovered but not processed, {x, y} is a back edge and it can't be a DAG</p>\n</li>\n<li>\n<p>if <em>y</em> is processed, it will have been labeled before <em>x</em> and therefore <em>x</em> appears before <em>y</em> in topological order, as it must.</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">process_vertex_late</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sorted<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">process_edge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> class<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* edge class */</span>\n    class <span class=\"token operator\">=</span> <span class=\"token function\">edge_classification</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>class <span class=\"token operator\">==</span> BACK<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Warning: Directed cycle found, not a DAG\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">topsort</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token function\">init_stack</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sorted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>discovered<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">print_stack</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sorted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* report topological order */</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Strongly Connected Components</h3>\n<p>A directed graph is strongly connected if there is a directed path between any two vertices. Graphs that are not strongly connected can be partitioned into strongly connected components. The set of such components and the weakly-connecting edges can be determined using DFS. All vertices in a directed cycle must be in the same strongly connected component. We can shrink/contract the vertices in the cycle and repeat. Process terminates when no directed cycle remains and each vertex represents a strongly connected component.</p>\n<p>We update our notion of oldest reachable vertex in response to (1) nontree edges and (2) backing up from a vertex. Because it's a directed graph, we have to worry about forward edges (from a vertex to a descendant) and cross edges (from a vertex back to a nonaancestor but previously discovered vertex). This algorithm will peel one strong component off at a time and assign each of its vertices the number of the component it is in:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">strong_components</span><span class=\"token punctuation\">(</span>graph <span class=\"token operator\">*</span>g<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* counter */</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token punctuation\">(</span>g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        low<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        scc<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    components_found <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">init_stack</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>active<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">initialize_search</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token punctuation\">(</span>g<span class=\"token operator\">-></span>nvertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>discovered<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> False<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Define low[v] to be the oldest vertex known to be in the same strongly connected component as v. Not necessarily an ancestor, but may be a distant cousin of v because of cross edges. Cross edges that point vertices from previous strongly connected components of the graph can't help because there is no way back from them to v, but otherwise they are fair game. Forward edges have no impact on reachability over depth-first tree edges and can be disregarded.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> low<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">/* oldest vertex surely in component of v */</span>\n<span class=\"token keyword\">int</span> scc<span class=\"token punctuation\">[</span>MAXV<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">/* strong component number of each vertex */</span>\n\nprocess_edge <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> class<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* edge class */</span>\n    class <span class=\"token operator\">=</span> <span class=\"token function\">edge_classification</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>class <span class=\"token operator\">==</span> BACK<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>entry_time<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> entry_time<span class=\"token punctuation\">[</span> low<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            low<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>class <span class=\"token operator\">==</span> CROSS<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>scc<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">/* component not yet assigned */</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>entry_time<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> entry_time<span class=\"token punctuation\">[</span> low<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                low<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>A new strongly connected component is found whenever the lowest reachable vertex from v is v. If so, we clear the stack of the component. Otherwise, we give our parent the benefit of the oldest ancestor we can reach and backtrack.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token function\">process_vertex_early</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>active<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">process_vertex_late</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* edge (parent[v], v) cutes of scc */</span>\n        <span class=\"token function\">pop_component</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">/* only if v is not the root */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>entry_time<span class=\"token punctuation\">[</span>low<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> entry_time<span class=\"token punctuation\">[</span>low<span class=\"token punctuation\">[</span>parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            low<span class=\"token punctuation\">[</span>parent<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> low<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">pop_component</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* vertex placeholder */</span>\n    components_found <span class=\"token operator\">=</span> components_found <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    scc<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> components_found<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">=</span> <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>active<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        scc<span class=\"token punctuation\">[</span>t<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> components_found<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>",
      "frontmatter": {
        "date": "2019-01-16",
        "title": "Algorithm Design Manual:",
        "chapter": "Chapter Five",
        "subtitle": "Graph Traversal",
        "tags": ["algorithms", "graphs", "Algorithm Design Manual"],
        "path": "/Algorithm-Design-Manual--Chapter-Five"
      }
    }
  },
  "pageContext": {
    "isCreatedByStatefulCreatePages": false,
    "pathSlug": "/Algorithm-Design-Manual--Chapter-Five",
    "prev": {
      "frontmatter": {
        "path": "/Algorithm-Design-Manual--Chapter-Four",
        "title": "Algorithm Design Manual:",
        "tags": [
          "algorithms",
          "sorting",
          "searching",
          "Algorithm Design Manual"
        ],
        "subtitle": "Sorting and Searching",
        "chapter": "Chapter Four"
      }
    },
    "next": {
      "frontmatter": {
        "path": "/Algorithm-Design-Manual--Chapter-Six",
        "title": "Algorithm Design Manual:",
        "tags": ["algorithms", "graphs", "Algorithm Design Manual"],
        "subtitle": "Weighted Graph Algorithms",
        "chapter": "Chapter Six"
      }
    }
  }
}
